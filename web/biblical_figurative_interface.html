<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tzafun</title>
    <style>
        /* Hebrew Font Support */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;600&family=Crimson+Text:wght@400;600;700&family=Inter:wght@400;500;600&display=swap');

        :root {
            /* Theme Colors */
            --color-primary: #2b394f;
            --color-accent: #007bff;
            --color-accent-hover: #0056b3;
            --color-text-main: #212529;
            --color-text-muted: #6c757d;
            --color-border: rgba(0, 0, 0, 0.1);
            --color-bg-body: #f0f2f5;

            /* Glassmorphism Tokens */
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: 1px solid rgba(255, 255, 255, 0.5);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            --glass-blur: 12px;

            /* Figurative Language Colors */
            --color-metaphor: #a0695f;
            --color-simile: #5a8ca8;
            --color-personification: #9370a8;
            --color-idiom: #c9a255;
            --color-hyperbole: #c17a61;
            --color-metonymy: #5d9b82;
            --color-other: #7a8896;

            /* Typography */
            --font-serif: 'Crimson Text', serif;
            --font-sans: 'Inter', sans-serif;
            --font-hebrew: 'Noto Sans Hebrew', serif;
        }

        /* Variable Mappings for Backward Compatibility/Existing Classes */
        :root {
            --metaphor-color: var(--color-metaphor);
            --simile-color: var(--color-simile);
            --personification-color: var(--color-personification);
            --idiom-color: var(--color-idiom);
            --hyperbole-color: var(--color-hyperbole);
            --metonymy-color: var(--color-metonymy);
            --other-color: var(--color-other);
            --sidebar-bg: var(--glass-bg);
            --main-bg: transparent;
            --border-color: var(--color-border);
            --text-color: var(--color-text-main);
            --accent-color: var(--color-accent);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-serif);
            line-height: 1.6;
            color: var(--color-text-main);
            background: linear-gradient(135deg, #e0e4e8 0%, #f0f2f5 100%);
            min-height: 100vh;
        }

        /* Main Layout Grid */
        .app-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            overflow: hidden;
        }

        /* Glass Header */
        .header {
            grid-column: 1 / -1;
            background: rgba(10, 25, 48, 0.85);
            /* Dark glass for header */
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-left {
            flex: 1;
        }

        .header h1 {
            font-family: var(--font-sans);
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 0;
            letter-spacing: -0.5px;
        }

        .header h1:hover {
            opacity: 0.9;
            cursor: pointer;
        }

        .header p {
            opacity: 0.85;
            font-size: 1.4rem;
            margin-bottom: 0;
            font-family: var(--font-serif);
        }

        .header-hebrew-quote {
            font-family: var(--font-hebrew);
            font-size: 1.3rem !important;
            opacity: 0.75;
            margin-top: 0;
        }

        .header-attribution {
            font-family: var(--font-sans);
            font-size: 1.05rem;
            color: rgba(255, 255, 255, 0.95);
            text-align: right;
        }

        .header-attribution a {
            color: white;
            text-decoration: none;
            cursor: pointer;
            font-weight: 600;
            opacity: 0.9;
            transition: opacity 0.2s, text-decoration 0.2s;
            letter-spacing: 0.5px;
        }

        .header-attribution a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* About Page Styles */
        .about-page {
            display: none;
            overflow-y: auto;
            height: 100%;
            grid-column: 1 / -1;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
        }

        .about-page.active {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
        }

        .about-toc {
            padding: 2rem;
            background: rgba(255, 255, 255, 0.5);
            border-right: var(--glass-border);
            height: 100%;
        }

        .about-toc h3 {
            font-family: var(--font-sans);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-primary);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-primary);
        }

        .about-toc ul {
            list-style: none;
        }

        .about-toc li {
            margin-bottom: 0.8rem;
        }

        .about-toc a {
            color: var(--color-text-main);
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s;
            display: block;
            padding: 0.2rem 0;
        }

        .about-toc a:hover {
            color: var(--color-accent);
        }

        .about-content {
            padding: 3rem 4rem;
            max-width: 1000px;
        }

        .about-page h2 {
            font-family: var(--font-sans);
            font-size: 2rem;
            color: var(--color-primary);
            margin: 2.5rem 0 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--color-border);
        }

        .about-page h2:first-child {
            margin-top: 0;
        }

        .about-page p {
            margin-bottom: 1rem;
            font-size: 1.15rem;
            line-height: 1.8;
        }

        /* Global Tooltip */
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: var(--color-primary);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: var(--color-primary) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
            bottom: 120%;
        }

        /* Glass Sidebar */
        .sidebar {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-right: 1px solid rgba(255, 255, 255, 0.4);
            padding: 1.5rem 1.5rem 5rem 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .sidebar section {
            margin-bottom: 0;
            /* Handled by flex gap */
        }

        /* Section Dividers */
        .sidebar section+section {
            padding-top: 1.25rem;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }

        .sidebar h3 {
            font-family: var(--font-sans);
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-text-muted);
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.5rem;
            width: 100%;
        }

        .sidebar label {
            display: flex;
            align-items: center;
            margin-bottom: 0.35rem;
            cursor: pointer;
            font-size: 1.05rem;
            color: var(--color-text-main);
        }

        .sidebar input,
        .sidebar select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: var(--font-sans);
            transition: all 0.2s;
        }

        .sidebar input:focus,
        .sidebar select:focus {
            outline: none;
            border-color: var(--color-accent);
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .sidebar input[type="checkbox"],
        .sidebar input[type="radio"] {
            width: auto;
            margin-right: 0.6rem;
            accent-color: var(--color-accent);
        }

        /* Custom Checkbox List for Books */
        .book-list-container {
            height: 160px;
            /* Slightly taller for better touch targets */
            padding: 0.5rem;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 2px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .book-list-container::-webkit-scrollbar {
            width: 6px;
        }

        .book-list-container::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.15);
            border-radius: 3px;
        }

        .book-checkbox-item {
            display: flex;
            align-items: center;
            padding: 0px 0.5rem;
            /* Tighter padding */
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.1s;
            user-select: none;
            line-height: 1.2;
            /* Tighter line height */
        }

        .book-checkbox-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .book-checkbox-item input[type="checkbox"] {
            width: auto;
            margin-right: 0.8rem;
            transform: scale(1.1);
            cursor: pointer;
        }

        .book-checkbox-item span {
            font-size: 0.95rem;
            color: var(--color-text-main);
        }

        /* Control Styles Refined */
        .control-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .control-header.mt {
            margin-top: 1rem;
        }

        .control-link {
            background: none;
            border: none;
            color: var(--color-accent);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: color 0.2s;
        }

        .control-link:hover {
            color: var(--color-accent-hover);
        }

        .control-separator {
            color: var(--color-border);
            margin: 0 4px;
        }

        .load-btn {
            width: 100%;
            padding: 0.9rem;
            background: linear-gradient(135deg, var(--color-primary) 0%, #3a4b66 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: all 0.2s ease;
            font-weight: 700;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 10px rgba(43, 57, 79, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(43, 57, 79, 0.4);
        }

        .load-btn::before {
            content: "➜";
            font-size: 1.1em;
        }

        /* Standardized Mini Buttons */
        .btn-mini {
            flex: 1;
            padding: 0.45rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            font-family: var(--font-sans);
            transition: all 0.2s ease;
        }

        .btn-mini-primary {
            background: var(--color-primary);
            color: white;
            border: 1px solid var(--color-primary);
        }

        .btn-mini-primary:hover {
            background: #1a2533;
        }

        .btn-mini-outline {
            background: white;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }

        .btn-mini-outline:hover {
            background: rgba(43, 57, 79, 0.05);
        }

        /* Standardized Refresh Button */
        .refresh-btn {
            background: none;
            border: none;
            color: var(--color-accent);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: color 0.2s, transform 0.2s;
            padding: 0.2rem;
            line-height: 1;
        }

        .refresh-btn:hover {
            color: var(--color-accent-hover);
            transform: rotate(30deg);
        }

        /* Type Filters */
        .type-filters label {
            gap: 0.6rem;
            padding: 0.3rem 0.5rem;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .type-filters label:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .filter-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            opacity: 0.8;
            flex-shrink: 0;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
        }

        .type-filters input:checked+.filter-color {
            opacity: 1;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 1), 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .filter-color.metaphor {
            background-color: var(--color-metaphor);
        }

        .filter-color.simile {
            background-color: var(--color-simile);
        }

        .filter-color.personification {
            background-color: var(--color-personification);
        }

        .filter-color.idiom {
            background-color: var(--color-idiom);
        }

        .filter-color.hyperbole {
            background-color: var(--color-hyperbole);
        }

        .filter-color.metonymy {
            background-color: var(--color-metonymy);
        }

        .filter-color.other {
            background-color: var(--color-other);
        }

        /* Main Content Area */
        .main-content {
            padding: 2rem;
            padding-bottom: 140px;
            overflow-y: auto;
            position: relative;
        }

        /* Verse Container */
        /* Verse Container & Grid */
        .verse-container {
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .verse-container:hover {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }

        .verse-header {
            background: linear-gradient(to right, #f8f9fa, white);
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            font-family: var(--font-sans);
            font-weight: 600;
            color: var(--color-primary);
            cursor: pointer;
            font-size: 1.05rem;
            display: flex;
            align-items: center;
        }

        /* Input Tooltips */
        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .input-wrapper input {
            padding-right: 28px !important;
        }

        .help-icon {
            position: absolute;
            right: 8px;
            width: 16px;
            height: 16px;
            background: rgba(0, 0, 0, 0.1);
            color: var(--color-text-muted);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5;
        }

        .help-icon:hover,
        .help-icon.active {
            background: var(--color-accent);
            color: white;
        }

        /* Global Tooltip */
        #global-tooltip {
            position: fixed;
            background: var(--color-primary);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 2000;
            /* Higher than other tooltips */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            /* Allow clicks to pass through when hidden */
        }

        #global-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--color-primary);
        }

        /* Prevent tooltip clipping in sidebar */
        .metadata-search .tooltip .tooltiptext {
            z-index: 1000;
            bottom: auto;
            top: 135%;
            /* Position below */
        }

        .metadata-search .tooltip .tooltiptext::after {
            top: auto;
            bottom: 100%;
            /* Arrow on top of tooltip */
            border-color: transparent transparent var(--color-primary) transparent;
        }

        /* Accordion Styles */
        .sidebar-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--color-border);
            margin-bottom: 1rem;
            transition: background 0.2s;
        }

        .sidebar-section-header:hover {
            opacity: 0.8;
        }

        .sidebar h3 {
            margin-bottom: 0 !important;
            /* Override default margin */
            border-bottom: none !important;
            /* Override default border */
            padding-bottom: 0 !important;
            flex: 1;
        }

        .accordion-icon {
            transition: transform 0.3s ease;
            width: 12px;
            height: 12px;
            border-right: 2px solid var(--color-text-muted);
            border-bottom: 2px solid var(--color-text-muted);
            transform: rotate(45deg);
            /* Pointing down */
            margin-left: 10px;
            margin-bottom: 4px;
        }

        .section-collapsed .accordion-icon {
            transform: rotate(-45deg);
            /* Pointing right */
            margin-bottom: 0;
            margin-left: 6px;
        }

        .accordion-content {
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease, margin 0.3s ease;
            max-height: 2000px;
            /* Arbitrary large value */
            opacity: 1;
        }

        .accordion-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
            /* Ensure no padding when collapsed */
        }

        .accordion-content.visible-overflow {
            overflow: visible;
        }

        .verse-header:hover {
            color: var(--color-accent);
        }

        .verse-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            padding: 2rem;
            position: relative;
            align-items: start;
            /* Fixes alignment for different text lengths */
        }

        .english-text {
            font-family: var(--font-serif);
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--color-text-main);
        }

        .hebrew-text {
            font-family: var(--font-hebrew);
            font-size: 1.4rem;
            line-height: 1.8;
            direction: rtl;
            text-align: right;
            color: var(--color-text-main);
        }

        /* Highlights */
        .figurative-highlight {
            background-color: rgba(255, 243, 205, 0.7);
            border-bottom: 2px solid rgba(255, 193, 7, 0.4);
            padding: 0 2px;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .figurative-highlight:hover {
            background-color: rgba(255, 243, 205, 1);
        }

        /* Tooltip Base */
        .type-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-primary);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .type-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--color-primary);
        }

        .figurative-highlight:hover .type-tooltip {
            opacity: 1;
            visibility: visible;
            bottom: calc(100% + 5px);
        }

        .type-indicator {
            display: inline-flex;
            align-items: center;
            margin-right: 8px;
            font-family: var(--font-sans);
            font-size: 0.8rem;
        }

        .type-indicator:last-child {
            margin-right: 0;
        }

        .type-color-square {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            margin-right: 6px;
        }

        .type-color-square.metaphor {
            background-color: var(--color-metaphor);
        }

        .type-color-square.simile {
            background-color: var(--color-simile);
        }

        .type-color-square.personification {
            background-color: var(--color-personification);
        }

        .type-color-square.idiom {
            background-color: var(--color-idiom);
        }

        .type-color-square.hyperbole {
            background-color: var(--color-hyperbole);
        }

        .type-color-square.metonymy {
            background-color: var(--color-metonymy);
        }

        .type-color-square.other {
            background-color: var(--color-other);
        }

        /* Detail Panel - Right Drawer */
        .detail-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 450px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(var(--glass-blur));
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            padding: 2rem;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            /* Higher than header (100) and stats content */
            overflow-y: auto;
            max-height: none;
        }

        .detail-panel.active {
            transform: translateX(0);
        }

        .detail-panel.annotation-details {
            max-height: none;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        .panel-header h3 {
            color: var(--color-primary);
            font-family: var(--font-sans);
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--color-text-muted);
            line-height: 1;
            padding: 0.2rem;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: var(--color-accent);
        }

        /* Annotation Details */
        .annotation-details:not(:empty) {
            background: white;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .annotation-phrase {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px dashed var(--color-border);
            align-items: center;
        }

        .annotation-phrase::after {
            content: '';
            grid-column: 2;
            width: 1px;
            height: 100%;
            background-color: var(--color-border);
        }

        .annotation-phrase-hebrew {
            font-family: var(--font-hebrew);
            font-size: 1.25rem;
            font-weight: 600;
            direction: rtl;
            text-align: right;
        }

        .annotation-phrase-english {
            font-family: var(--font-serif);
            font-size: 1.15rem;
            font-weight: 600;
        }

        .type-badges {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .type-indicator {
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: white;
            margin: 0;
            background-color: #6c757d;
            /* default */
        }

        .type-indicator.metaphor {
            background-color: var(--color-metaphor);
        }

        .type-indicator.simile {
            background-color: var(--color-simile);
        }

        .type-indicator.personification {
            background-color: var(--color-personification);
        }

        .type-indicator.idiom {
            background-color: var(--color-idiom);
        }

        .type-indicator.hyperbole {
            background-color: var(--color-hyperbole);
        }

        .type-indicator.metonymy {
            background-color: var(--color-metonymy);
        }

        .type-indicator.other {
            background-color: var(--color-other);
        }

        /* Deliberation Section */
        .deliberation-section {
            background: #f8f9fa;
            border-left: 4px solid var(--color-accent);
            padding: 1.5rem;
            border-radius: 0 8px 8px 0;
            margin-top: 1.5rem;
        }

        .deliberation-section h4 {
            color: var(--color-accent);
            margin-bottom: 1rem;
            font-family: var(--font-sans);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #deliberation-text {
            font-family: var(--font-serif);
            line-height: 1.8;
            color: var(--color-text-main);
            white-space: pre-wrap;
        }

        #deliberation-text .deliberation-item {
            margin-bottom: 1.2rem;
            padding-left: 1.5rem;
            text-indent: -1.5rem;
        }

        #deliberation-text .deliberation-number {
            font-weight: 600;
            color: var(--color-accent);
            margin-right: 0.5rem;
        }

        #deliberation-text .deliberation-bold {
            font-weight: 600;
            color: var(--color-text-main);
        }

        #deliberation-text .deliberation-italic {
            font-style: italic;
            color: var(--color-text-muted);
        }

        #deliberation-text .deliberation-label {
            font-weight: 600;
            color: var(--color-accent);
        }

        .model-badge {
            display: inline-block;
            background-color: #e9ecef;
            color: var(--color-text-muted);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.5rem;
            font-family: var(--font-sans);
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--color-text-muted);
            font-family: var(--font-sans);
        }

        .spinner {
            display: inline-block;
            width: 2.5rem;
            height: 2.5rem;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-top: 3px solid var(--color-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Mobile Elements (Hidden by default on Desktop) */
        .mobile-menu-btn {
            display: none;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--font-sans);
            font-weight: 600;
            font-size: 0.9rem;
            margin-right: 1rem;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.2s;
        }

        .mobile-menu-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .sidebar-overlay.active {
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                display: block;
                /* Stack layout */
                height: auto;
                /* Fix scrolling by allowing auto height */
                min-height: 100vh;
                overflow-x: hidden;
                overflow-y: visible;
                /* Fix scrolling */
            }

            /* Header Adjustments */
            .header {
                padding: 0.8rem 1rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
                position: sticky;
                top: 0;
                width: 100%;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header p {
                font-size: 1rem;
            }

            .header-hebrew-quote {
                display: none;
                /* Hide quote on mobile to save space */
            }

            .mobile-menu-btn {
                display: inline-flex;
                /* Show on mobile */
            }

            /* Sidebar Drawer */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                width: 280px;
                transform: translateX(-100%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 1000;
                border-right: 1px solid rgba(255, 255, 255, 0.4);
                box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
                padding-bottom: 2rem;
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .sidebar-overlay.active {
                display: block;
            }

            /* Main Content Scrolling */
            .main-content {
                padding: 1rem;
                padding-bottom: 80px;
                /* Space for stats bar */
                height: auto;
                overflow-y: visible;
                /* Let body scroll */
            }

            /* Verse Container Stack */
            .verse-content {
                grid-template-columns: 1fr;
                gap: 1.5rem;
                padding: 1.25rem;
            }

            .hebrew-text {
                font-size: 1.25rem;
                order: -1;
                /* Hebrew first on mobile stack? Or keep english first? Let's keep existing order */
                /* Actually user complaint was "can't see verses", stacking is key. */
                order: 0;
                margin-bottom: 0.5rem;
            }

            .english-text {
                font-size: 1.05rem;
            }

            /* Detail Panel Full Screen */
            .detail-panel {
                width: 100%;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                top: auto;
                /* Bottom sheet style */
                bottom: 0;
                height: 80vh;
                border-radius: 12px 12px 0 0;
                left: 0;
            }

            .detail-panel.active {
                transform: translateY(0);
            }

            /* Stats Bar Compact */
            .stats-bar {
                flex-direction: column;
                gap: 0.8rem;
                text-align: center;
                padding: 0.8rem;
            }
        }

        /* Stats Bar */
        .stats-bar {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(var(--glass-blur));
            padding: 0.8rem 1.5rem;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--color-text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            font-family: var(--font-sans);
            font-size: 0.9rem;
        }

        .stats-text {
            flex: 1;
        }

        .nav-button {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: 0.6rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--font-sans);
            font-weight: 600;
            transition: all 0.2s;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Hebrew Keyboard */
        .search-type-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--color-primary);
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s;
            color: var(--color-primary);
            font-family: var(--font-sans);
        }

        .toggle-btn:hover {
            background-color: var(--color-bg-body);
        }

        .toggle-btn.active {
            background-color: var(--color-primary);
            color: white;
        }

        .hebrew-keyboard {
            display: none;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #e9ecef;
            border-radius: 6px;
        }

        .hebrew-keyboard.active {
            display: grid;
        }

        .hebrew-key {
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 8px 0;
            text-align: center;
            cursor: pointer;
            font-family: var(--font-hebrew);
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 32px;
        }

        .hebrew-key:hover {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }

        .hebrew-key.wide {
            grid-column: span 2;
        }

        .hebrew-key.action {
            font-family: var(--font-sans);
            font-size: 0.8rem;
        }

        .search-input-container {
            position: relative;
            margin-bottom: 0.5rem;
        }

        .keyboard-toggle {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid var(--color-primary);
            cursor: pointer;
            color: var(--color-primary);
            border-radius: 4px;
            padding: 2px 6px;
            z-index: 10;
        }

        #search-input {
            margin-bottom: 0;
            padding-right: 4.5rem;
        }

        .clear-search-btn {
            position: absolute;
            right: 2.8rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--color-accent);
            font-size: 1rem;
            font-weight: 600;
            z-index: 10;
            display: none;
            transition: color 0.2s, transform 0.2s;
        }

        .clear-search-btn:hover {
            color: var(--color-accent-hover);
            transform: translateY(-50%) rotate(30deg);
        }

        .clear-search-btn.active {
            display: block;
        }

        /* Search Highlight */
        .search-highlight {
            background-color: transparent !important;
            border-bottom: 3px solid #ffb3d9;
            font-weight: 700;
        }

        .figurative-highlight .search-highlight {
            background-color: transparent;
            box-shadow: none;
        }

        /* Print Styles */
        @media print {

            .sidebar,
            .header,
            .stats-bar,
            .detail-panel,
            .navigation,
            .about-page,
            .keyboard-toggle,
            .search-input-container,
            .clear-search-btn {
                display: none !important;
            }

            .app-container {
                display: block;
                height: auto;
                overflow: visible;
            }

            .main-content {
                padding: 0;
                overflow: visible;
                padding-bottom: 0;
                max-height: none;
            }

            .verse-container {
                page-break-inside: avoid;
                border: 1px solid #000;
                margin-bottom: 30px;
                box-shadow: none;
                display: block;
            }

            .verse-header {
                background: none;
                border-bottom: 1px solid #000;
                color: black;
                padding: 10px;
            }

            .verse-content {
                display: block;
                padding: 10px;
            }

            .verse-content>.hebrew-text,
            .verse-content>.english-text {
                display: none !important;
            }

            .verse-text-columns {
                display: grid !important;
                grid-template-columns: 1fr 2px 1fr;
                gap: 15px;
                padding-bottom: 15px;
                margin-bottom: 15px;
                border-bottom: 1px solid #ccc;
            }

            .verse-text-columns::after {
                content: '';
                grid-column: 2;
                width: 1px;
                height: 100%;
                background: #999;
                justify-self: center;
            }

            .hebrew-text {
                grid-column: 1;
                direction: rtl;
                text-align: right;
                font-size: 14pt;
            }

            .english-text {
                grid-column: 3;
                font-size: 14pt;
            }

            .figurative-highlight {
                background-color: #ffeb3b !important;
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
                padding: 0 2px;
            }

            .search-highlight {
                border-bottom: 2px solid #ffb3d9;
            }

            /* Print specific sections */
            .print-header {
                display: block !important;
                border-bottom: 1px solid black;
                margin-bottom: 20px;
                padding-bottom: 10px;
            }

            .print-header h1 {
                margin: 0;
                font-size: 24pt;
            }

            .print-deliberation {
                display: block !important;
                background: #f9f9f9 !important;
                border-left: 3px solid #007bff;
                padding: 10px;
                margin-top: 10px;
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
                page-break-inside: avoid;
            }

            .print-deliberation h4 {
                font-size: 14pt;
                margin-top: 0;
                color: #007bff;
            }

            .print-annotation {
                display: block !important;
                border: 1px solid #999;
                padding: 10px;
                margin-top: 10px;
                page-break-inside: avoid;
            }

            .type-indicator.metaphor {
                background-color: var(--color-metaphor) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.simile {
                background-color: var(--color-simile) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.personification {
                background-color: var(--color-personification) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.idiom {
                background-color: var(--color-idiom) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.hyperbole {
                background-color: var(--color-hyperbole) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.metonymy {
                background-color: var(--color-metonymy) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            .type-indicator.other {
                background-color: var(--color-other) !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
            }

            /* Hide the normal tooltips in print */
            .type-tooltip {
                display: none !important;
            }
        }

        .print-header,
        .print-deliberation,
        .print-annotation,
        .verse-text-columns {
            display: none;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div style="display: flex; align-items: center;">
                    <button class="mobile-menu-btn" onclick="toggleSidebar()">
                        ☰ Filters
                    </button>
                    <div>
                        <h1 onclick="showMainPage()">Tzafun</h1>
                        <p>A concordance of Biblical figurative language</p>
                        <p class="header-hebrew-quote">מה רב־טובך אשר־צפנת ליראיך (Psalms 31:20)</p>
                    </div>
                </div>
            </div>
            <div class="header-attribution">
                <a onclick="showAboutPage()">about</a><br>
                <a onclick="printPage()">print</a>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- 1. Search for Figurative Language -->
            <section class="figurative-search-section">
                <div class="sidebar-section-header" onclick="toggleAccordion(this)">
                    <h3 class="tooltip" style="width: auto;">
                        Search for Figurative Language
                        <span class="tooltiptext">Search by rhetorical fields (Target, Vehicle, etc.)</span>
                    </h3>
                    <div class="accordion-icon"></div>
                </div>
                <div class="accordion-content">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="font-size: 0.85rem; color: #6c757d;">Separate multiple terms with ;</span>
                        <button id="clear-metadata-btn" onclick="clearMetadataSearch()" class="refresh-btn"
                            title="Clear tag search">↻</button>
                    </div>
                    <div class="metadata-search"
                        style="margin-top: 0; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div class="input-wrapper">
                            <input type="text" id="target-search" placeholder="Target"
                                title="Target: The subject being described (e.g., &quot;God&quot;, &quot;Life&quot;).">
                            <div class="help-icon tooltip">?
                                <span class="tooltiptext">Target: The subject being described (e.g., "God",
                                    "Life").</span>
                            </div>
                        </div>
                        <div class="input-wrapper">
                            <input type="text" id="vehicle-search" placeholder="Vehicle"
                                title="Vehicle: The image used for description (e.g., &quot;Rock&quot;, &quot;Journey&quot;).">
                            <div class="help-icon tooltip">?
                                <span class="tooltiptext">Vehicle: The image used for description (e.g., "Rock",
                                    "Journey").</span>
                            </div>
                        </div>
                        <div class="input-wrapper">
                            <input type="text" id="ground-search" placeholder="Ground"
                                title="Ground: The common quality or meaning (e.g., &quot;Strength&quot;, &quot;Difficulty&quot;).">
                            <div class="help-icon tooltip">?
                                <span class="tooltiptext">Ground: The common quality or meaning (e.g., "Strength",
                                    "Difficulty").</span>
                            </div>
                        </div>
                        <div class="input-wrapper">
                            <input type="text" id="posture-search" placeholder="Posture"
                                title="Posture: The rhetorical intent or emotion (e.g., &quot;Praise&quot;, &quot;Complaint&quot;).">
                            <div class="help-icon tooltip">?
                                <span class="tooltiptext">Posture: The rhetorical intent or emotion (e.g., "Praise",
                                    "Complaint").</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 2. Search Biblical Text -->
            <section class="biblical-text-search">
                <div class="sidebar-section-header" onclick="toggleAccordion(this)">
                    <h3>Search Biblical Text</h3>
                    <div class="accordion-icon"></div>
                </div>
                <div class="accordion-content">
                    <!-- Search Type Toggle -->
                    <div class="search-type-toggle">
                        <button class="toggle-btn active" id="english-toggle"
                            onclick="toggleSearchType('english')">English</button>
                        <button class="toggle-btn" id="hebrew-toggle"
                            onclick="toggleSearchType('hebrew')">עברית</button>
                    </div>

                    <!-- Search Input with Clear and Keyboard Toggle -->
                    <div class="search-input-container">
                        <input type="text" id="search-input" placeholder="Search English text...">
                        <button class="clear-search-btn" id="clear-search-btn" onclick="clearTextSearch()"
                            title="Clear Search">↻</button>
                        <button class="keyboard-toggle" id="keyboard-toggle" onclick="toggleHebrewKeyboard()"
                            title="Toggle Hebrew Keyboard">⌨</button>
                    </div>

                    <!-- Hebrew Virtual Keyboard - Compact rectangular layout -->
                    <div class="hebrew-keyboard" id="hebrew-keyboard">
                        <!-- Row 1: 9 letters -->
                        <div class="hebrew-key" onclick="insertHebrew('א')">א</div>
                        <div class="hebrew-key" onclick="insertHebrew('ב')">ב</div>
                        <div class="hebrew-key" onclick="insertHebrew('ג')">ג</div>
                        <div class="hebrew-key" onclick="insertHebrew('ד')">ד</div>
                        <div class="hebrew-key" onclick="insertHebrew('ה')">ה</div>
                        <div class="hebrew-key" onclick="insertHebrew('ו')">ו</div>
                        <div class="hebrew-key" onclick="insertHebrew('ז')">ז</div>
                        <div class="hebrew-key" onclick="insertHebrew('ח')">ח</div>
                        <div class="hebrew-key" onclick="insertHebrew('ט')">ט</div>
                        <!-- Row 2: 9 letters -->
                        <div class="hebrew-key" onclick="insertHebrew('י')">י</div>
                        <div class="hebrew-key" onclick="insertHebrew('כ')">כ</div>
                        <div class="hebrew-key" onclick="insertHebrew('ל')">ל</div>
                        <div class="hebrew-key" onclick="insertHebrew('מ')">מ</div>
                        <div class="hebrew-key" onclick="insertHebrew('נ')">נ</div>
                        <div class="hebrew-key" onclick="insertHebrew('ס')">ס</div>
                        <div class="hebrew-key" onclick="insertHebrew('ע')">ע</div>
                        <div class="hebrew-key" onclick="insertHebrew('פ')">פ</div>
                        <div class="hebrew-key" onclick="insertHebrew('צ')">צ</div>
                        <!-- Row 3: 9 letters (4 regular + 5 final forms) -->
                        <div class="hebrew-key" onclick="insertHebrew('ק')">ק</div>
                        <div class="hebrew-key" onclick="insertHebrew('ר')">ר</div>
                        <div class="hebrew-key" onclick="insertHebrew('ש')">ש</div>
                        <div class="hebrew-key" onclick="insertHebrew('ת')">ת</div>
                        <div class="hebrew-key" onclick="insertHebrew('ך')">ך</div>
                        <div class="hebrew-key" onclick="insertHebrew('ם')">ם</div>
                        <div class="hebrew-key" onclick="insertHebrew('ן')">ן</div>
                        <div class="hebrew-key" onclick="insertHebrew('ף')">ף</div>
                        <div class="hebrew-key" onclick="insertHebrew('ץ')">ץ</div>
                        <!-- Row 4: Action keys -->
                        <div class="hebrew-key action" onclick="clearSearch()" style="grid-column: span 2;">Clear</div>
                        <div class="hebrew-key" onclick="insertHebrew(' ')" style="grid-column: span 5;">Space</div>
                        <div class="hebrew-key action" onclick="deleteLastChar()" style="grid-column: span 2;">⌫</div>
                    </div>
                </div>
            </section>

            <!-- 3. Filter by Text Scope -->
            <section class="book-selection section-collapsed">
                <div class="sidebar-section-header" onclick="toggleAccordion(this)">
                    <h3>Filter by Text</h3>
                    <div class="accordion-icon"></div>
                </div>
                <div class="accordion-content collapsed">
                    <!-- Book Selection Controls -->
                    <div class="control-header">
                        <label style="margin-bottom: 0;">Books:</label>
                        <div class="control-group">
                            <button onclick="selectAllBooks()" class="control-link"
                                title="Select all books">All</button>
                            <span class="control-separator">|</span>
                            <button onclick="clearAllBooks()" class="control-link" title="Clear all books">None</button>
                        </div>
                    </div>

                    <div id="book-select-container" class="book-list-container">
                        <div class="loading" style="padding: 1rem; text-align: left;">Loading books...</div>
                    </div>

                    <!-- Chapters Input -->
                    <div class="control-header mt">
                        <label for="chapter-input" style="margin-bottom: 0;">Chapters:</label>
                        <button onclick="document.getElementById('chapter-input').value='all'; filterAndRenderVerses();"
                            class="refresh-btn" title="Reset to all chapters">↻</button>
                    </div>
                    <input type="text" id="chapter-input" placeholder="e.g., 1,3,5-7 or 'all'">

                    <!-- Verses Input -->
                    <div class="control-header mt">
                        <label for="verse-input" style="margin-bottom: 0;">Verses:</label>
                        <button onclick="document.getElementById('verse-input').value='all'; filterAndRenderVerses();"
                            class="refresh-btn" title="Reset to all verses">↻</button>
                    </div>
                    <input type="text" id="verse-input" placeholder="e.g., 1-5,10,15 or 'all'">

                    <button id="load-verses" class="load-btn">Load Verses</button>
                </div>
            </section>

            <!-- 4. Figurative Language Types (Refinement) -->
            <section class="type-filters section-collapsed">
                <div class="sidebar-section-header" onclick="toggleAccordion(this)">
                    <h3>Figurative Language Types</h3>
                    <div class="accordion-icon"></div>
                </div>
                <div class="accordion-content collapsed">
                    <!-- Select All / Clear All Buttons -->
                    <div class="control-header">
                        <label style="margin-bottom: 0;">Types:</label>
                        <div class="control-group">
                            <button id="select-all-types" class="control-link" title="Select all types">All</button>
                            <span class="control-separator">|</span>
                            <button id="clear-all-types" class="control-link" title="Clear all types">None</button>
                        </div>
                    </div>

                    <label
                        title="A comparison where one thing is said to be another (e.g., &quot;God is my rock&quot;)">
                        <input type="checkbox" value="metaphor" checked>
                        <span class="filter-color metaphor"></span>
                        Metaphor
                    </label>
                    <label
                        title="A comparison using &quot;like&quot; or &quot;as&quot; (e.g., &quot;like a deer pants for water&quot;)">
                        <input type="checkbox" value="simile" checked>
                        <span class="filter-color simile"></span>
                        Simile
                    </label>
                    <label
                        title="Giving human qualities to non-human things (e.g., &quot;the mountains skipped like rams&quot;)">
                        <input type="checkbox" value="personification" checked>
                        <span class="filter-color personification"></span>
                        Personification
                    </label>
                    <label
                        title="A phrase with a meaning different from its literal words (e.g., &quot;fruit of the womb&quot;)">
                        <input type="checkbox" value="idiom" checked>
                        <span class="filter-color idiom"></span>
                        Idiom
                    </label>
                    <label title="Exaggeration for emphasis (e.g., &quot;rivers of tears flow from my eyes&quot;)">
                        <input type="checkbox" value="hyperbole" checked>
                        <span class="filter-color hyperbole"></span>
                        Hyperbole
                    </label>
                    <label
                        title="Using one thing to represent another closely related thing (e.g., &quot;the sword&quot; for war)">
                        <input type="checkbox" value="metonymy" checked>
                        <span class="filter-color metonymy"></span>
                        Metonymy
                    </label>
                    <label title="Other forms of figurative language not fitting the main categories">
                        <input type="checkbox" value="other" checked>
                        <span class="filter-color other"></span>
                        Other
                    </label>
                    <label title="Verses with no figurative language identified">
                        <input type="checkbox" value="not_figurative">
                        <span class="filter-color" style="background-color: #6c757d;"></span>
                        Not Figurative
                    </label>
                </div>
            </section>

            <!-- 5. Text Version (Advanced) -->
            <section class="text-options section-collapsed">
                <div class="sidebar-section-header" onclick="toggleAccordion(this)">
                    <h3 class="tooltip">Text Version
                        <span class="tooltiptext">See About section for details</span>
                    </h3>
                    <div class="accordion-icon"></div>
                </div>
                <div class="accordion-content collapsed">
                    <div>
                        <label><input type="radio" name="text-version" value="sacred" checked> Sacred Names</label>
                        <label><input type="radio" name="text-version" value="non-sacred"> Traditional Jewish</label>
                    </div>
                </div>
            </section>
        </aside>

        <!-- Main Content -->
        <main class="main-content" id="main-content">
            <!-- Print Header (hidden on screen, shown when printing) -->
            <div class="print-header" id="print-header">
                <!-- Will be populated by JavaScript when printing -->
            </div>

            <div id="verses-container">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                </div>
            </div>

            <!-- Stats and Navigation Bar at Bottom -->
            <div class="stats-bar" id="stats-bar">
                Loading...
            </div>
        </main>

        <!-- About Page -->
        <div class="about-page" id="about-page">
            <!-- Table of Contents -->
            <div class="about-toc">
                <h3>Contents</h3>
                <ul>
                    <li><a href="#section-tzafun">Tzafun</a></li>
                    <li><a href="#section-information">The information in Tzafun</a></li>
                    <li><a href="#section-sacred">Sacred Names</a></li>
                    <li><a href="#section-documentation">More documentation</a></li>
                    <li><a href="#section-acknowledgements">Acknowledgements</a></li>
                </ul>
            </div>

            <!-- Main Content -->
            <div class="about-content">
                <h2 id="section-tzafun">Tzafun</h2>
                <p>"Tzafun" (צָפֻן) means "hidden" or "concealed" and also implies treasure, as in Psalms 31:20: "How
                    abundant is the good that You have in store (צָפַ֢נְתָּ) for those who fear You" and Psalm 119:11:
                    "I have treasured (צָפַ֣נְתִּי) Your word in my heart."</p>
                <p>The Biblical text is a treasure house of rich figurative language, sometimes clear, sometimes
                    mysterious. It's an essential part of the text's power and eternality. Often, the student's work
                    would benefit from a wide search for some element of figurative speech across a wide corpus of
                    Biblical texts, in the same way as one can search for a particular word or root in a Concordance.
                    Creating a database to enable this would be a great deal of work for humans. Tzafun started with the
                    question: couldn't we use modern Large Language Models (LLMs) to help compile this 'concordance' of
                    biblical figurative speech?</p>
                <p>Tzafun was created by having LLMs "read" the text of the Bible verse by verse, in English and Hebrew,
                    and tag instances of figurative speech, including similes, metaphors, hyperbole, idioms,
                    personification and metonymy.</p>
                <p>This is a two-stage process. A first AI agent reads the verse, deliberates and identifies figurative
                    speech. A second AI agent reviews the work of the first, validating, invalidating or reclassifying
                    the initial tags. Tzafun records the final result, as well as the deliberations of both agents.</p>

                <h2 id="section-information">The information in Tzafun</h2>
                <p><strong>Coverage:</strong> Tzafun currently includes 13 biblical books with over 13,500 verses
                    analyzed:</p>
                <ul style="margin-left: 2rem; margin-bottom: 1rem;">
                    <li><strong>Torah (Pentateuch):</strong> Genesis, Exodus, Leviticus, Numbers, Deuteronomy</li>
                    <li><strong>Wisdom Literature:</strong> Psalms, Proverbs</li>
                    <li><strong>Major Prophets:</strong> Isaiah, Jeremiah, Ezekiel</li>
                    <li><strong>Minor Prophets (Twelve):</strong> Hosea, Joel, Amos</li>
                </ul>
                <p>Each verse is shown in Hebrew (Masoretic) and English (JPS 2006). Examples of figurative speech that
                    were identified by the first agent and validated by the second are highlighted. If you click on the
                    header above any verse, you can see the LLM's deliberations. If you click on a highlighted example
                    of figurative speech, you can also see the following information:</p>
                <p><strong>Target</strong> what or who the figurative speech is about</p>
                <p><strong>Vehicle</strong> what the target is being likened to</p>
                <p><strong>Ground</strong> what quality of the target is being illuminated by the figurative speech</p>
                <p><strong>Posture</strong> purpose of the speech; emotional valence</p>
                <p>Example: "כִּֽי־עָפָ֣ר אַ֔תָּה"/ "For dust you are" (Gen 3:19). Target = humans; Vehicle = dust;
                    Ground = humble origin, ephemerality; Posture = solemn declaration</p>
                <p>To make these easier to search, the LLM was instructed to generate a hierarchy of tags for each of
                    these fields. For example, if the vehicle of the metaphor is bees, the LLM will record "bees →
                    insects → animals". A search for any of these terms will identify Psalms 118:12 "סַבּ֤וּנִי
                    כִדְבוֹרִ֗ים"/ "They have beset me like bees".</p>
                <p><strong>Explanation</strong> The LLM's explanation of the figurative speech.</p>
                <p><strong>Validation reasons</strong> The second agent's deliberations about whether to
                    validate/invalidate/reclassify a phrase tagged by the first agent as figurative speech.</p>
                <p><strong>Speaker</strong> The LLM's assessment of who is speaking the figurative language.</p>
                <p><strong>Confidence</strong> The LLM's level of confidence that this is figurative language.</p>
                <p><strong>Name of the model</strong> Most verses were processed by GPT-5.1, with Claude Opus 4.5 and
                    Gemini 3.0 Pro as fallback models. The model name is shown with each verse's deliberation.</p>

                <h2 id="section-sacred">Sacred Names</h2>
                <p>Traditional Jews who are printing results from Tzafun may wish to avoid printing Divine names that
                    they consider sacred. They can select 'Traditional Jewish' versions of the verses, which replace
                    divine Names with traditional abbreviations.</p>

                <h2 id="section-documentation">More documentation</h2>
                <p>Complete project documentation is available on GitHub at <a
                        href="https://github.com/ARobicsek/bible-figurative-language"
                        target="_blank">github.com/ARobicsek/bible-figurative-language</a></p>

                <h3>Available Documentation:</h3>
                <ul>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/README.md"
                                target="_blank">README</a></strong> - Project overview, installation, and quick start
                        guide</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/METHODOLOGY.md"
                                target="_blank">Methodology</a></strong> - Detailed explanation of the two-stage AI
                        analysis process, model selection, and validation approach</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/DATABASE_SCHEMA.md"
                                target="_blank">Database Schema</a></strong> - Complete database structure and field
                        definitions</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/FEATURES.md"
                                target="_blank">Features Guide</a></strong> - Comprehensive guide to using the web
                        interface</li>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/FAQ.md"
                                target="_blank">FAQ</a></strong> - Frequently asked questions about the project and its
                        data</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/CONTRIBUTING.md"
                                target="_blank">Contributing</a></strong> - How to contribute feedback, report issues,
                        or validate classifications</li>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/SETUP.md"
                                target="_blank">Setup Guide</a></strong> - Instructions for running Tzafun locally</li>
                </ul>

                <h3>Citation & Licensing:</h3>
                <p>If you use Tzafun in your research or teaching, please cite it appropriately. Citation formats
                    (BibTeX, APA, MLA) and licensing information are available in the <a
                        href="https://github.com/ARobicsek/bible-figurative-language/blob/main/CITATION.cff"
                        target="_blank">CITATION.cff</a> file.</p>
                <ul>
                    <li><strong>Code License:</strong> MIT License - see <a
                            href="https://github.com/ARobicsek/bible-figurative-language/blob/main/LICENSE-CODE.txt"
                            target="_blank">LICENSE-CODE.txt</a></li>
                    <li><strong>Data License:</strong> Creative Commons Attribution 4.0 (CC BY 4.0) - see <a
                            href="https://github.com/ARobicsek/bible-figurative-language/blob/main/LICENSE-DATA.txt"
                            target="_blank">LICENSE-DATA.txt</a></li>
                </ul>

                <h2 id="section-acknowledgements">Acknowledgements</h2>
                <p>Text from Sefaria.org.</p>
                <p>Hebrew: Miqra According to the Masorah (MAM).</p>
                <p>English: Jewish Publication Society, 2006.</p>
                <p>&copy; 2025 Ari Robicsek</p>
            </div>
        </div>

        <!-- Bottom Detail Panel -->
        <div class="detail-panel" id="detail-panel">
            <div class="panel-header">
                <h3>Verse Details: <span id="selected-verse"></span></h3>
                <button class="close-btn" id="close-panel">&times;</button>
            </div>

            <div class="panel-content">
                <div class="annotation-details" id="annotation-details">
                    <!-- Dynamically populated when annotation is clicked -->
                </div>

                <div class="deliberation-section">
                    <h4>Figurative Detection Deliberation</h4>
                    <p id="deliberation-text">Click on a verse to see the AI's deliberation process...</p>
                    <span class="model-badge" id="model-used"></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const appState = {
            verses: [],
            filteredVerses: [],
            selectedTypes: new Set(['metaphor', 'simile', 'personification', 'idiom', 'hyperbole', 'metonymy', 'other']),
            showNotFigurative: false,
            textVersion: 'sacred', // 'sacred' or 'non-sacred' - applies to all text fields
            searchType: 'english', // 'hebrew' or 'english'
            currentSearch: {
                text: '',
                target: '',
                vehicle: '',
                ground: '',
                posture: ''
            },
            pagination: {
                limit: 25,
                offset: 0,
                total: 0,
                hasMore: false,
                total_figurative_instances: 0,
                countIsEstimate: false  // Track if count is an estimate
            },
            loading: false,
            requestCounter: 0,  // Track request order to handle race conditions
            countRequestCounter: 0  // Track background count requests
        };

        // API Configuration - use relative URL to work in both dev and production
        const API_BASE = '/api';

        // Page Navigation Functions
        function showAboutPage() {
            document.getElementById('main-content').style.display = 'none';
            document.querySelector('.sidebar').style.display = 'none';
            document.getElementById('about-page').classList.add('active');
            document.getElementById('about-page').style.gridColumn = '1 / -1';
        }

        function showMainPage() {
            document.getElementById('main-content').style.display = 'block';
            document.querySelector('.sidebar').style.display = 'block';
            document.getElementById('about-page').classList.remove('active');
        }

        // Book Selection Helper Functions
        function selectAllBooks() {
            const bookSelect = document.getElementById('book-select');
            for (let i = 0; i < bookSelect.options.length; i++) {
                bookSelect.options[i].selected = true;
            }
            // Clear chapter/verse inputs and close detail panel
            resetChapterVerseInputs();
            closeDetailPanel();
        }

        function clearAllBooks() {
            const bookSelect = document.getElementById('book-select');
            for (let i = 0; i < bookSelect.options.length; i++) {
                bookSelect.options[i].selected = false;
            }
            // Clear chapter/verse inputs and close detail panel
            resetChapterVerseInputs();
            closeDetailPanel();
        }

        // Reset chapter and verse inputs when book selection changes
        function resetChapterVerseInputs() {
            document.getElementById('chapter-input').value = '';
            document.getElementById('verse-input').value = '';
        }

        // Print Functions
        function removeFootnotes(text) {
            if (!text) return text;

            // Remove content within quotes that appears to be footnotes/annotations
            // Pattern matches quoted phrases that contain explanatory text like "lit.", "cf.", "trad.", etc.
            let cleaned = text.replace(/"[^"]*(?:lit\.|cf\.|trad\.|NJPS|uncertain|connected with|often in)[^"]*"/gi, '');

            // Clean up any double spaces left behind
            cleaned = cleaned.replace(/\s{2,}/g, ' ');

            // Clean up spaces before punctuation
            cleaned = cleaned.replace(/\s+([,.])/g, '$1');

            return cleaned.trim();
        }

        function generatePrintSummary() {
            const summary = [];

            // Get selected books
            const bookSelect = document.getElementById('book-select');
            const selectedBooks = Array.from(bookSelect.selectedOptions).map(opt => opt.text);
            if (selectedBooks.length > 0) {
                summary.push(`<strong>Books:</strong> ${selectedBooks.join(', ')}`);
            }

            // Get selected chapters
            const chapterInput = document.getElementById('chapter-input').value;
            if (chapterInput && chapterInput.trim() !== '' && chapterInput.trim().toLowerCase() !== 'all') {
                summary.push(`<strong>Chapters:</strong> ${chapterInput}`);
            }

            // Get selected verses
            const verseInput = document.getElementById('verse-input').value;
            if (verseInput && verseInput.trim() !== '' && verseInput.trim().toLowerCase() !== 'all') {
                summary.push(`<strong>Verses:</strong> ${verseInput}`);
            }

            // Get figurative types
            const selectedTypes = Array.from(appState.selectedTypes);
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };
            const typeNames = selectedTypes.map(t => typeLabels[t]);
            if (appState.showNotFigurative) {
                typeNames.push('Not Figurative');
            }
            if (typeNames.length > 0) {
                summary.push(`<strong>Figurative Types:</strong> ${typeNames.join(', ')}`);
            }

            // Get text version
            const textVersion = document.querySelector('input[name="text-version"]:checked').value;
            summary.push(`<strong>Text Version:</strong> ${textVersion === 'sacred' ? 'Sacred Names' : 'Traditional Jewish'}`);

            // Get search terms
            if (appState.currentSearch.text) {
                const searchType = appState.searchType === 'hebrew' ? 'Hebrew' : 'English';
                summary.push(`<strong>${searchType} Search:</strong> "${appState.currentSearch.text}"`);
            }

            // Get metadata search terms
            const metadataTerms = [];
            if (appState.currentSearch.target) {
                metadataTerms.push(`Target: "${appState.currentSearch.target}"`);
            }
            if (appState.currentSearch.vehicle) {
                metadataTerms.push(`Vehicle: "${appState.currentSearch.vehicle}"`);
            }
            if (appState.currentSearch.ground) {
                metadataTerms.push(`Ground: "${appState.currentSearch.ground}"`);
            }
            if (appState.currentSearch.posture) {
                metadataTerms.push(`Posture: "${appState.currentSearch.posture}"`);
            }
            if (metadataTerms.length > 0) {
                summary.push(`<strong>Metadata Search:</strong> ${metadataTerms.join('; ')}`);
            }

            // Get verse count
            const verseCount = appState.filteredVerses ? appState.filteredVerses.length : 0;
            summary.push(`<strong>Verses Displayed:</strong> ${verseCount}`);

            return summary;
        }

        function preparePrintContent() {
            const textVersion = document.querySelector('input[name="text-version"]:checked').value;
            const useNonSacred = textVersion === 'non-sacred';

            // Generate filter summary header
            const summaryItems = generatePrintSummary();
            const summaryHTML = `
                <h1>Tzafun: Biblical Figurative Language Analysis</h1>
                <p style="font-style: italic;">A concordance of Biblical figurative language</p>
                <h2>Applied Filters and Selections</h2>
                <div class="filter-summary">
                    ${summaryItems.map(item => `<p>${item}</p>`).join('')}
                </div>
            `;
            document.getElementById('print-header').innerHTML = summaryHTML;

            // Get all verse containers
            const verseContainers = document.querySelectorAll('.verse-container');

            // For each verse, add print-specific content
            appState.filteredVerses.forEach((verse, index) => {
                const verseElement = verseContainers[index];
                if (!verseElement) return;

                // Remove any existing print elements
                verseElement.querySelectorAll('.print-deliberation, .print-annotation, .verse-text-columns').forEach(el => el.remove());

                // Get the Hebrew and English text from the existing display
                const hebrewTextElement = verseElement.querySelector('.hebrew-text');
                const englishTextElement = verseElement.querySelector('.english-text');

                // Create a wrapper for the text columns at the top
                if (hebrewTextElement && englishTextElement) {
                    const textColumnsHTML = `
                        <div class="verse-text-columns">
                            <div class="hebrew-text">${hebrewTextElement.innerHTML}</div>
                            <div class="english-text">${englishTextElement.innerHTML}</div>
                        </div>
                    `;
                    verseElement.querySelector('.verse-content').insertAdjacentHTML('afterbegin', textColumnsHTML);
                }

                // Add annotation details for each figurative instance FIRST (on top)
                if (verse.annotations && verse.annotations.length > 0) {
                    verse.annotations.forEach(annotation => {
                        const annotationHTML = createPrintAnnotation(annotation, useNonSacred);
                        verseElement.querySelector('.verse-content').insertAdjacentHTML('beforeend', annotationHTML);
                    });
                }

                // Add deliberation section AFTER annotations (on bottom)
                const deliberationField = useNonSacred ?
                    (verse.figurative_detection_deliberation_non_sacred || verse.figurative_detection_deliberation) :
                    verse.figurative_detection_deliberation;

                if (deliberationField) {
                    const modelName = verse.model_used || 'Unknown Model';
                    const formattedDeliberation = formatDeliberationText(deliberationField);
                    const deliberationHTML = `
                        <div class="print-deliberation">
                            <h4>Figurative Detection Deliberation<span class="model-badge">${modelName}</span></h4>
                            <div class="deliberation-content">${formattedDeliberation}</div>
                        </div>
                    `;
                    verseElement.querySelector('.verse-content').insertAdjacentHTML('beforeend', deliberationHTML);
                }
            });
        }

        function createPrintAnnotation(annotation, useNonSacred) {
            const hebrewPhrase = useNonSacred ?
                (annotation.figurative_text_in_hebrew_non_sacred || annotation.figurative_text_in_hebrew) :
                annotation.figurative_text_in_hebrew;
            const englishPhrase = useNonSacred ?
                (annotation.figurative_text_non_sacred || annotation.figurative_text) :
                annotation.figurative_text;

            // Get all active types
            const activeTypes = annotation.types || [];
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };

            const typeIndicators = activeTypes.map(type =>
                `<span class="type-indicator ${type}">${typeLabels[type]}</span>`
            ).join(' ');

            // Build annotation details
            const details = [];

            if (annotation.target) {
                const targetValue = Array.isArray(annotation.target) ? annotation.target.join(' → ') : annotation.target;
                details.push(`<strong>Target:</strong> ${targetValue}`);
            }

            if (annotation.vehicle) {
                const vehicleValue = Array.isArray(annotation.vehicle) ? annotation.vehicle.join(' → ') : annotation.vehicle;
                details.push(`<strong>Vehicle:</strong> ${vehicleValue}`);
            }

            if (annotation.ground) {
                const groundValue = Array.isArray(annotation.ground) ? annotation.ground.join(' → ') : annotation.ground;
                details.push(`<strong>Ground:</strong> ${groundValue}`);
            }

            if (annotation.posture) {
                const postureValue = Array.isArray(annotation.posture) ? annotation.posture.join(' → ') : annotation.posture;
                details.push(`<strong>Posture:</strong> ${postureValue}`);
            }

            if (annotation.confidence !== undefined) {
                details.push(`<strong>Confidence:</strong> ${annotation.confidence}`);
            }

            if (annotation.speaker) {
                details.push(`<strong>Speaker:</strong> ${annotation.speaker}`);
            }

            if (annotation.purpose) {
                details.push(`<strong>Purpose:</strong> ${annotation.purpose}`);
            }

            if (annotation.explanation) {
                details.push(`<strong>Explanation:</strong> ${annotation.explanation}`);
            }

            // Add validation reasons for each type
            const validationReasons = [];
            activeTypes.forEach(type => {
                const reasonKey = `validation_reason_${type}`;
                if (annotation[reasonKey]) {
                    validationReasons.push(`<strong>${typeLabels[type]} Validation:</strong> ${annotation[reasonKey]}`);
                }
            });

            return `
                <div class="print-annotation">
                    <h5>Annotation Details</h5>
                    <div class="annotation-phrase">
                        <div class="annotation-phrase-hebrew">${hebrewPhrase || ''}</div>
                        <div class="annotation-phrase-english">${englishPhrase || ''}</div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Figurative Types:</strong> ${typeIndicators}
                    </div>
                    ${details.map(detail => `<p>${detail}</p>`).join('')}
                    ${validationReasons.length > 0 ? '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ccc;">' + validationReasons.map(reason => `<p>${reason}</p>`).join('') + '</div>' : ''}
                </div>
            `;
        }

        function printPage() {
            // Prepare the content for printing
            preparePrintContent();

            // Trigger the browser's print dialog
            window.print();

            // Clean up print-specific content after printing
            setTimeout(() => {
                document.querySelectorAll('.print-deliberation, .print-annotation').forEach(el => el.remove());
                document.getElementById('print-header').innerHTML = '';
            }, 1000);
        }

        // DOM Elements
        const elements = {
            versesContainer: document.getElementById('verses-container'),
            detailPanel: document.getElementById('detail-panel'),
            selectedVerse: document.getElementById('selected-verse'),
            deliberationText: document.getElementById('deliberation-text'),
            modelUsed: document.getElementById('model-used'),
            annotationDetails: document.getElementById('annotation-details'),
            statsBar: document.getElementById('stats-bar'),
            loadBtn: document.getElementById('load-verses'),
            closePanel: document.getElementById('close-panel')
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function () {
            initializeEventListeners();
            loadStatistics();
            loadDefaultVerses(); // Load verses immediately
        });

        function initializeEventListeners() {
            // Book selection change - clear chapter/verse and close panel
            // Book selection change - delegated to container
            document.getElementById('book-select-container').addEventListener('change', function (e) {
                if (e.target.matches('input[type="checkbox"]')) {
                    resetChapterVerseInputs();
                    closeDetailPanel();
                }
            });

            // Type filter checkboxes
            document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    if (this.value === 'not_figurative') {
                        appState.showNotFigurative = this.checked;
                    } else {
                        if (this.checked) {
                            appState.selectedTypes.add(this.value);
                        } else {
                            appState.selectedTypes.delete(this.value);
                        }
                    }
                    closeDetailPanel(); // Close panel when filter changes
                    filterAndRenderVerses();
                });
            });

            // Text version radio buttons
            document.querySelectorAll('input[name="text-version"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    appState.textVersion = this.value;
                    renderVerses();
                    // Update deliberation text if a verse is currently shown
                    const currentVerse = appState.verses.find(v => v.reference === elements.selectedVerse.textContent);
                    if (currentVerse) {
                        updateDeliberationDisplay(currentVerse);
                    }
                });
            });

            // Create debounced search function ONCE
            const debouncedSearch = debounce(handleSearch, 300);

            // Search inputs
            document.getElementById('search-input').addEventListener('input', function () {
                updateClearButtonVisibility();
                closeDetailPanel(); // Close panel when new search starts
                debouncedSearch();
            });

            // Metadata search listeners - auto-uncheck "Not Figurative" when metadata search is active
            const metadataInputs = ['target-search', 'vehicle-search', 'ground-search', 'posture-search'];
            metadataInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', function () {
                    if (this.value.trim()) {
                        uncheckNotFigurativeForMetadataSearch();
                    }
                    closeDetailPanel(); // Close panel when tag search changes
                    debouncedSearch();
                });
            });

            // Panel controls
            elements.closePanel.addEventListener('click', closeDetailPanel);
            elements.loadBtn.addEventListener('click', loadVerses);

            // Select All / Clear All buttons for figurative language types
            document.getElementById('select-all-types').addEventListener('click', function () {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (!checkbox.checked) {
                        checkbox.checked = true;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = true;
                        } else {
                            appState.selectedTypes.add(checkbox.value);
                        }
                    }
                });
                closeDetailPanel(); // Close panel when filter changes
                filterAndRenderVerses();
            });

            document.getElementById('clear-all-types').addEventListener('click', function () {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (checkbox.checked) {
                        checkbox.checked = false;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = false;
                        } else {
                            appState.selectedTypes.delete(checkbox.value);
                        }
                    }
                });
                closeDetailPanel(); // Close panel when filter changes
                filterAndRenderVerses();
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function uncheckNotFigurativeForMetadataSearch() {
            // Auto-uncheck "Not Figurative" when metadata search is active to avoid complex queries
            const notFigCheckbox = document.querySelector('input[value="not_figurative"]');
            if (notFigCheckbox && notFigCheckbox.checked) {
                notFigCheckbox.checked = false;
                appState.showNotFigurative = false;
            }
        }

        function handleSearch() {
            appState.currentSearch = {
                text: document.getElementById('search-input').value,
                target: document.getElementById('target-search').value,
                vehicle: document.getElementById('vehicle-search').value,
                ground: document.getElementById('ground-search').value,
                posture: document.getElementById('posture-search').value
            };
            filterAndRenderVerses();
        }

        // Hebrew Keyboard Functions
        function toggleSearchType(type) {
            appState.searchType = type;
            const hebrewToggle = document.getElementById('hebrew-toggle');
            const englishToggle = document.getElementById('english-toggle');
            const searchInput = document.getElementById('search-input');
            const keyboardToggle = document.getElementById('keyboard-toggle');

            if (type === 'hebrew') {
                hebrewToggle.classList.add('active');
                englishToggle.classList.remove('active');
                searchInput.placeholder = 'Search Hebrew text...';
                searchInput.style.direction = 'rtl';
                searchInput.style.textAlign = 'right';
                keyboardToggle.style.display = 'block';
            } else {
                englishToggle.classList.add('active');
                hebrewToggle.classList.remove('active');
                searchInput.placeholder = 'Search English text...';
                searchInput.style.direction = 'ltr';
                searchInput.style.textAlign = 'left';
                keyboardToggle.style.display = 'none';
                document.getElementById('hebrew-keyboard').classList.remove('active');
            }

            // Clear search when switching types
            const hadSearch = searchInput.value !== '';
            searchInput.value = '';
            updateClearButtonVisibility();

            // Only trigger search if there was actually a search term to clear
            if (hadSearch) {
                handleSearch();
            }
        }

        function toggleHebrewKeyboard() {
            const keyboard = document.getElementById('hebrew-keyboard');
            keyboard.classList.toggle('active');
        }

        function toggleAccordion(header) {
            const section = header.parentElement;
            const content = section.querySelector('.accordion-content');

            // Toggle classes
            section.classList.toggle('section-collapsed');
            content.classList.toggle('collapsed');

            // Handle overflow for tooltips
            if (!section.classList.contains('section-collapsed')) {
                // Expanding: Wait for transition then set overflow visible
                setTimeout(() => {
                    if (!section.classList.contains('section-collapsed')) {
                        content.style.overflow = 'visible';
                    }
                }, 400); // Match CSS transition time
            } else {
                // Collapsing: Set overflow hidden immediately
                content.style.overflow = 'hidden';
            }
        }

        function insertHebrew(char) {
            const input = document.getElementById('search-input');
            const cursorPos = input.selectionStart;
            const value = input.value;
            input.value = value.substring(0, cursorPos) + char + value.substring(cursorPos);
            input.setSelectionRange(cursorPos + char.length, cursorPos + char.length);
            input.focus();
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearSearch() {
            document.getElementById('search-input').value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearTextSearch() {
            const input = document.getElementById('search-input');
            input.value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function deleteLastChar() {
            const input = document.getElementById('search-input');
            if (input.value.length > 0) {
                input.value = input.value.slice(0, -1);
                updateClearButtonVisibility();
                handleSearch();
            }
        }

        function updateClearButtonVisibility() {
            const input = document.getElementById('search-input');
            const clearBtn = document.getElementById('clear-search-btn');
            if (input.value.length > 0) {
                clearBtn.classList.add('active');
            } else {
                clearBtn.classList.remove('active');
            }
        }

        function clearMetadataSearch() {
            document.getElementById('target-search').value = '';
            document.getElementById('vehicle-search').value = '';
            document.getElementById('ground-search').value = '';
            document.getElementById('posture-search').value = '';
            handleSearch();
        }

        // API Functions
        async function makeAPICall(endpoint, params = {}) {
            try {
                // Build URL with query parameters - use relative URL directly with fetch
                const url = new URL(`${API_BASE}${endpoint}`, window.location.origin);
                Object.keys(params).forEach(key => {
                    if (params[key] !== '' && params[key] !== null && params[key] !== undefined) {
                        url.searchParams.append(key, params[key]);
                    }
                });

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                return null;
            }
        }

        // Database selection functions removed - now using fixed database

        async function loadStatistics() {
            try {
                const stats = await makeAPICall('/statistics');
                if (stats) {
                    console.log('Database statistics:', stats);
                    // Update book selection options
                    updateBookOptions(stats.books);
                }
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        function updateBookOptions(books) {
            // Render checkboxes in the new container
            const container = document.getElementById('book-select-container');

            if (!books || books.length === 0) {
                container.innerHTML = '<div style="padding:1rem;">No books found</div>';
                return;
            }

            container.innerHTML = books.map(book => `
                <label class="book-checkbox-item">
                    <input type="checkbox" value="${book.toLowerCase()}" checked>
                    <span>${book}</span>
                </label>
            `).join('');

            // Add change listener for delegations
            // Remove any old ones if possible, but adding a new one is safe-ish if we handle it right
            // The container is replaced, so previous listeners on children are gone.
            // Listener on container itself (if added in DOMContentLoaded) persists.
        }

        function getSelectedBooks() {
            const container = document.getElementById('book-select-container');
            if (!container) return [];
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        function selectAllBooks() {
            const container = document.getElementById('book-select-container');
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            closeDetailPanel();
            resetChapterVerseInputs();
        }

        function clearAllBooks() {
            const container = document.getElementById('book-select-container');
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            closeDetailPanel();
            resetChapterVerseInputs();
        }

        async function loadDefaultVerses() {
            // Load all books (empty string = all)
            await loadVersesFromAPI({
                books: '', // Empty string implies all books
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                limit: 25,
                offset: 0
            });
        }

        async function loadVersesFromAPI(params = {}) {
            // Increment request counter to track this specific request
            appState.requestCounter++;
            const thisRequestId = appState.requestCounter;

            appState.loading = true;
            showLoading();

            try {
                const data = await makeAPICall('/verses', params);

                // Only process results if this is still the most recent request
                // This prevents race conditions where an older request completes after a newer one
                if (thisRequestId === appState.requestCounter && data) {
                    appState.verses = data.verses;
                    // Convert API response to frontend format
                    appState.pagination = {
                        ...data.pagination,
                        hasMore: data.pagination.has_more, // Convert snake_case to camelCase
                        total_figurative_instances: data.pagination.total_figurative_instances || 0
                    };

                    // Check if count is an estimate (0 instances = mixed query estimate)
                    // This happens when show_all_verses or show_not_figurative is enabled
                    const show_all_verses = appState.selectedTypes.size === 7 && appState.showNotFigurative;
                    const show_not_figurative = appState.showNotFigurative;
                    const isEstimate = (data.pagination.total_figurative_instances === 0 && (show_all_verses || show_not_figurative));
                    appState.pagination.countIsEstimate = isEstimate;

                    appState.filteredVerses = appState.verses; // API already filters
                    renderVerses();
                    updateStats();

                    // Trigger lazy count loading if estimate
                    if (isEstimate) {
                        loadExactCount(params);
                    }
                } else if (thisRequestId !== appState.requestCounter) {
                    // This request was superseded by a newer one, ignore results
                    console.log(`Ignoring stale API response (request ${thisRequestId}, current ${appState.requestCounter})`);
                } else if (!data) {
                    showError('Failed to load verses. Please ensure the API server is running.');
                }
            } catch (error) {
                // Only show error if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    console.error('Failed to load verses:', error);
                    showError('Failed to load verses. Please check your connection and try again.');
                }
            } finally {
                // Only clear loading state if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    appState.loading = false;
                }
            }
        }

        async function loadExactCount(params) {
            // Increment count request counter
            appState.countRequestCounter++;
            const thisCountRequestId = appState.countRequestCounter;

            try {
                // Build params for count endpoint (exclude limit and offset)
                const countParams = { ...params };
                delete countParams.limit;
                delete countParams.offset;

                console.log('Loading exact count in background...');
                const data = await makeAPICall('/verses/count', countParams);

                // Only update if this is still the most recent count request
                if (thisCountRequestId === appState.countRequestCounter && data) {
                    appState.pagination.total = data.total;
                    appState.pagination.total_figurative_instances = data.total_figurative_instances;
                    appState.pagination.countIsEstimate = false;
                    updateStats(); // Refresh display with exact count
                    console.log(`Exact count loaded: ${data.total} verses, ${data.total_figurative_instances} instances`);
                }
            } catch (error) {
                console.error('Failed to load exact count:', error);
                // Silently fail - estimate is good enough
            }
        }

        function showLoading() {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                    <p style="font-size: 0.9rem; opacity: 0.7; margin-top: 0.5rem;">First load may take up to 1 minute</p>
                </div>
            `;
        }

        function showError(message) {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <p style="color: #e74c3c;">⚠️ ${message}</p>
                    <button onclick="loadDefaultVerses()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;">
                        Try Again
                    </button>
                </div>
            `;
        }

        function filterAndRenderVerses() {
            // Default to 'all' if inputs are empty
            const chapterInput = document.getElementById('chapter-input');
            const verseInput = document.getElementById('verse-input');

            if (!chapterInput.value.trim()) {
                chapterInput.value = 'all';
            }
            if (!verseInput.value.trim()) {
                verseInput.value = 'all';
            }

            // Check if user has selected nothing (clear all scenario)
            if (appState.selectedTypes.size === 0 && !appState.showNotFigurative) {
                // Show NO verses when clear all is pressed (user's request)
                elements.versesContainer.innerHTML = '<div class="loading"><p>No figurative language types selected. Please select at least one type to see verses.</p></div>';
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        No verses displayed - no figurative language types selected
                    </div>
                    <div></div>
                `;
                return;
            }

            // Reset pagination offset when filter changes
            appState.pagination.offset = 0;

            // Since filtering is now done server-side, we just need to reload with current filters
            const params = buildAPIParams();
            loadVersesFromAPI(params);
        }

        function buildAPIParams() {
            const books = getSelectedBooks();
            const chapters = document.getElementById('chapter-input').value;
            const verses = document.getElementById('verse-input').value;

            return {
                books: books.join(','),
                chapters: chapters || 'all',
                verses: verses || 'all',
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                search_hebrew: appState.searchType === 'hebrew' ? appState.currentSearch.text : '',
                search_english: appState.searchType === 'english' ? appState.currentSearch.text : '',
                search_target: appState.currentSearch.target,
                search_vehicle: appState.currentSearch.vehicle,
                search_ground: appState.currentSearch.ground,
                search_posture: appState.currentSearch.posture,
                limit: appState.pagination.limit,
                offset: appState.pagination.offset
            };
        }

        /*
 * ROBUST TEXT HIGHLIGHTING ENGINE
 * Handles HTML tags, Hebrew normalization, and complex overlapping highlights (figurative + search).
 * Supports word-order subsequence matching for English to handle annotation/verse text mismatches.
 */
        class TextHighlighter {
            // Toggle for verbose console logging - set via: TextHighlighter.DEBUG = true
            static DEBUG = false;

            constructor() { }

            // Tokenize text into words (for subsequence matching)
            static tokenize(text) {
                if (!text) return [];
                // Split on whitespace, filter empties
                return text.split(/\s+/).filter(w => w.length > 0);
            }

            static normalizeHebrew(text) {
                if (!text) return '';
                return text.normalize('NFD')
                    .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove vowels/cantillation
                    .replace(/־/g, ' ') // Maqaf to space
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            // Maps indices from a source string to a "cleaned" string (e.g., HTML -> Plain)
            // returns { text: string, map: [] } where map[cleanIndex] = sourceIndex
            static buildMap(sourceText) {
                let cleanText = '';
                const map = [];

                let i = 0;
                while (i < sourceText.length) {
                    const char = sourceText[i];

                    // Check for HTML tag
                    if (char === '<') {
                        const tagMatch = sourceText.substring(i).match(/^<[^>]+>/);
                        if (tagMatch) {
                            const tag = tagMatch[0].toLowerCase();
                            // If it's a block-level-ish tag or break, add a space to avoid merging words
                            // e.g. "word<br>word" -> "word word", "end</div><div>start" -> "end start"
                            if (tag.includes('<br') || tag.includes('<div') || tag.includes('<p') || tag.includes('</div') || tag.includes('</p')) {
                                // Add a space in the plain text mapped to this tag start
                                map.push(i);
                                cleanText += ' ';
                            }

                            i += tagMatch[0].length;
                            continue;
                        }
                    }

                    // Check for common HTML entities
                    if (char === '&') {
                        const entityMatch = sourceText.substring(i).match(/^&([a-zA-Z0-9#]+);/);
                        if (entityMatch) {
                            const entity = entityMatch[1];
                            let decoded = ' ';
                            if (entity === 'nbsp') decoded = ' ';
                            else if (entity === 'amp') decoded = '&';
                            else if (entity === 'lt') decoded = '<';
                            else if (entity === 'gt') decoded = '>';
                            else if (entity === 'quot') decoded = '"';
                            else if (entity === 'apos') decoded = "'";

                            // Map the start of the entity to this decoded char
                            map.push(i);
                            cleanText += decoded;
                            i += entityMatch[0].length;
                            continue;
                        }
                    }

                    // Regular char
                    map.push(i);
                    cleanText += char;
                    i++;
                }

                return { text: cleanText, map };
            }

            // Step 2: Normalize the Plain Text (Plain -> Normalized)
            static buildNormalizationMap(plainText, language) {
                let normalizedText = '';
                const map = []; // map[normIndex] = plainIndex

                for (let i = 0; i < plainText.length; i++) {
                    const char = plainText[i];

                    if (language === 'hebrew') {
                        // Hebrew Logic
                        if (/[\u0591-\u05C7\u05F0-\u05F4]/.test(char)) {
                            // Skip diacritic
                            continue;
                        }
                        if (char === '־') {
                            map.push(i);
                            normalizedText += ' ';
                            continue;
                        }
                        map.push(i);
                        normalizedText += char;
                    } else {
                        // English Logic - STRICTER normalization
                        // Skip ALL punctuation, brackets, parens, quotes (smart and straight)
                        // Keep only letters, numbers, and spaces
                        if (/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/.test(char)) {
                            // Skip punctuation
                            continue;
                        }

                        // Collapse whitespace
                        if (/\s/.test(char)) {
                            if (normalizedText.length > 0 && normalizedText[normalizedText.length - 1] === ' ') {
                                // Already have a space, just map this one to the existing space (or skip mapping?)
                                // Actually, if we skip mapping, then " " -> " ".
                                // We want "  " -> " ".
                                // If we don't map it, highlighting won't cover the second space.
                                // But normalized matching doesn't care about the second space's index.
                                // We'll just continue.
                                continue;
                            }
                            map.push(i);
                            normalizedText += ' ';
                            continue;
                        }

                        map.push(i);
                        normalizedText += char.toLowerCase();
                    }
                }

                return { text: normalizedText, map };
            }

            // Helper to strip parenthetical/bracketed glosses from figurative text (e.g. "foo (lit. bar)")
            static cleanFigurativeText(text, language) {
                if (!text) return '';
                if (language === 'hebrew') return text;

                // Remove known parenthetical info (lit., Heb., meaning, etc.)
                let coreText = text.replace(/\s*\((?:lit\.|Heb\.|meaning|i\.e\.).*?\)/gi, '');

                // Clean up whitespace

                // Clean up whitespace
                return coreText.replace(/\s+/g, ' ').trim();
            }

            // Main Entry: Find Ranges
            // Returns [{start, end, type, data}] (indices in original HTML)
            static findRanges(html, annotations, searchTerm, language) {
                const results = [];

                // 1. HTML -> Plain
                const plainObj = this.buildMap(html);

                // 2. Plain -> Normalized
                const normObj = this.buildNormalizationMap(plainObj.text, language);

                // DEBUG: Log the normalized text once per call
                if (this.DEBUG && annotations.length > 0) {
                    console.group(`%cTextHighlighter [${language}]`, 'color: #007bff; font-weight: bold');
                    console.log('Plain text:', plainObj.text.substring(0, 150));
                    console.log('Normalized:', normObj.text.substring(0, 150));
                }

                // 3. Search for Annotations
                annotations.forEach(ann => {
                    const phrase = language === 'hebrew' ? ann.figurative_text_in_hebrew : ann.figurative_text;
                    if (!phrase) return;

                    // Clean the figurative phrase first (remove "lit." etc)
                    const cleanPhrase = this.cleanFigurativeText(phrase, language);

                    // Normalize the target phrase using same logic
                    let normPhrase = '';
                    if (language === 'hebrew') {
                        normPhrase = cleanPhrase.normalize('NFD')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '')
                            .replace(/־/g, ' ');
                    } else {
                        // For English, normalize same way as the text
                        normPhrase = cleanPhrase.toLowerCase().replace(/[.,;:!?()\[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '');
                    }

                    if (!normPhrase) return;

                    let matchFound = false;

                    // ====== ENGLISH: Word-Order Subsequence Matching ======
                    // PRIMARY matching strategy for English.
                    // Tokenizes annotation and finds each word in order within verse,
                    // allowing extra words in between (handles paraphrasing).
                    if (language !== 'hebrew') {
                        const annotationWords = this.tokenize(normPhrase);

                        if (this.DEBUG) {
                            console.log('---');
                            console.log('Annotation:', phrase);
                            console.log('Cleaned:', cleanPhrase);
                            console.log('Normalized:', normPhrase);
                            console.log('Tokens:', annotationWords);
                        }

                        if (annotationWords.length > 0) {
                            // Find first word as anchor
                            let searchPos = 0;
                            while (true) {
                                const firstWordIdx = normObj.text.indexOf(annotationWords[0], searchPos);
                                if (firstWordIdx === -1) break;

                                // Try to find remaining words in sequence
                                let pos = firstWordIdx + annotationWords[0].length;
                                let allFound = true;
                                let lastMatchEnd = pos;

                                for (let i = 1; i < annotationWords.length; i++) {
                                    const word = annotationWords[i];
                                    const wordIdx = normObj.text.indexOf(word, pos);

                                    if (wordIdx === -1) {
                                        allFound = false;
                                        break;
                                    }

                                    // Gap limit: max ~50 chars between words
                                    if (wordIdx - pos > 50) {
                                        allFound = false;
                                        break;
                                    }

                                    pos = wordIdx + word.length;
                                    lastMatchEnd = pos;
                                }

                                if (allFound) {
                                    results.push({
                                        startNorm: firstWordIdx,
                                        endNorm: lastMatchEnd,
                                        type: 'figurative',
                                        priority: 1,
                                        data: ann
                                    });
                                    matchFound = true;

                                    if (this.DEBUG) {
                                        console.log('%c✓ SUBSEQUENCE MATCH', 'color: green',
                                            `[${firstWordIdx}:${lastMatchEnd}]`);
                                    }
                                }

                                searchPos = firstWordIdx + 1;
                            }
                        }

                        // Fallback 1: Try exact substring match
                        if (!matchFound) {
                            let pos = 0;
                            while (true) {
                                const idx = normObj.text.indexOf(normPhrase, pos);
                                if (idx === -1) break;

                                results.push({
                                    startNorm: idx,
                                    endNorm: idx + normPhrase.length,
                                    type: 'figurative',
                                    priority: 1,
                                    data: ann
                                });
                                matchFound = true;

                                if (this.DEBUG) {
                                    console.log('%c✓ EXACT MATCH', 'color: green', `[${idx}:${idx + normPhrase.length}]`);
                                }

                                pos = idx + 1;
                            }
                        }

                        // Fallback 2: Proximity-based (bag-of-words) matching
                        // Handles word-order inversions like "are you" vs "you are"
                        if (!matchFound && annotationWords.length >= 2) {
                            const windowSize = Math.max(normPhrase.length + 20, 60);
                            const verseWords = this.tokenize(normObj.text);

                            // Create word position map
                            const wordPositions = {};
                            let charPos = 0;
                            verseWords.forEach(word => {
                                const idx = normObj.text.indexOf(word, charPos);
                                if (!wordPositions[word]) wordPositions[word] = [];
                                wordPositions[word].push(idx);
                                charPos = idx + word.length;
                            });

                            // Find first annotation word in verse
                            const firstWord = annotationWords[0];
                            if (wordPositions[firstWord]) {
                                for (const startIdx of wordPositions[firstWord]) {
                                    // Check if all words exist within window (both before AND after)
                                    const windowStart = Math.max(0, startIdx - windowSize / 2);
                                    const windowEnd = startIdx + windowSize;
                                    let allInWindow = true;
                                    let minPos = startIdx;
                                    let maxPos = startIdx + firstWord.length;

                                    for (let i = 1; i < annotationWords.length; i++) {
                                        const word = annotationWords[i];
                                        const positions = wordPositions[word] || [];
                                        // Look BOTH directions: before and after anchor
                                        const inWindow = positions.find(p =>
                                            p >= windowStart && p < windowEnd
                                        );

                                        if (inWindow === undefined) {
                                            allInWindow = false;
                                            break;
                                        }
                                        minPos = Math.min(minPos, inWindow);
                                        maxPos = Math.max(maxPos, inWindow + word.length);
                                    }

                                    if (allInWindow) {
                                        results.push({
                                            startNorm: minPos,
                                            endNorm: maxPos,
                                            type: 'figurative',
                                            priority: 1,
                                            data: ann
                                        });
                                        matchFound = true;

                                        if (this.DEBUG) {
                                            console.log('%c✓ PROXIMITY MATCH', 'color: orange',
                                                `[${minPos}:${maxPos}]`);
                                        }
                                        break; // Found one match, stop
                                    }
                                }
                            }
                        }

                        if (this.DEBUG && !matchFound) {
                            console.log('%c✗ NO MATCH', 'color: red');
                        }
                    } else {
                        // ====== HEBREW: Exact Match (unchanged) ======
                        let pos = 0;
                        while (true) {
                            const idx = normObj.text.indexOf(normPhrase, pos);
                            if (idx === -1) break;

                            results.push({
                                startNorm: idx,
                                endNorm: idx + normPhrase.length,
                                type: 'figurative',
                                priority: 1,
                                data: ann
                            });

                            pos = idx + 1;
                        }
                    }
                });

                if (this.DEBUG && annotations.length > 0) {
                    console.log(`Total figurative matches: ${results.length}`);
                    console.groupEnd();
                }


                // 4. Search for SearchTerm
                if (searchTerm) {
                    let normSearch = '';
                    if (language === 'hebrew') {
                        normSearch = searchTerm.normalize('NFD')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '')
                            .replace(/־/g, ' ');
                    } else {
                        // For English search, be a bit more flexible with partial matches? 
                        // Current logic matches 'man' in 'human'.
                        normSearch = searchTerm.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '');
                    }

                    if (normSearch) {
                        let pos = 0;
                        while (true) {
                            const idx = normObj.text.indexOf(normSearch, pos);
                            if (idx === -1) break;

                            results.push({
                                startNorm: idx,
                                endNorm: idx + normSearch.length,
                                type: 'search',
                                priority: 2,
                                data: searchTerm
                            });
                            pos = idx + 1;
                        }
                    }
                }

                // 5. Convert Norm Indices to HTML Indices
                const validRanges = [];
                results.forEach(r => {
                    // map norm -> plain
                    if (r.startNorm >= normObj.map.length) return;

                    const pStart = normObj.map[r.startNorm];

                    let pEnd;
                    if (r.endNorm < normObj.map.length) {
                        pEnd = normObj.map[r.endNorm];
                    } else {
                        pEnd = plainObj.text.length;
                    }

                    // map plain -> html
                    if (pStart >= plainObj.map.length) return;
                    const hStart = plainObj.map[pStart];

                    let hEnd;
                    if (pEnd < plainObj.map.length) {
                        hEnd = plainObj.map[pEnd];
                    } else {
                        // Safe fallback for end of string
                        hEnd = html.length;
                    }

                    validRanges.push({
                        start: hStart,
                        end: hEnd,
                        type: r.type,
                        priority: r.priority,
                        data: r.data
                    });
                });

                return validRanges;
            }

            // Step 6. Apply Highlights
            static applyHighlights(html, ranges) {
                if (ranges.length === 0) return html;

                // Flatten to points: { index, type: 'start'|'end', priority, ... }
                const points = [];
                ranges.forEach((r, i) => {
                    points.push({ idx: r.start, type: 'start', priority: r.priority, id: i, data: r.data, rangeType: r.type });
                    points.push({ idx: r.end, type: 'end', priority: r.priority, id: i, data: r.data, rangeType: r.type });
                });

                points.sort((a, b) => {
                    if (a.idx !== b.idx) return a.idx - b.idx;
                    // Order at same index: Ends before Starts (Visual containment)
                    return a.type === 'end' ? -1 : 1;
                });

                let result = '';
                let lastIdx = 0;

                let activeFigurative = null;
                let activeSearch = false;

                for (let i = 0; i < points.length; i++) {
                    const point = points[i];

                    // Add text up to this point
                    if (point.idx > lastIdx) {
                        const chunk = html.substring(lastIdx, point.idx);

                        let wrapped = chunk;

                        if (activeSearch) {
                            wrapped = `<span class="search-highlight">${wrapped}</span>`;
                        }
                        if (activeFigurative) {
                            wrapped = createFigurativeTag(wrapped, activeFigurative);
                        }

                        result += wrapped;
                    }

                    // Update state
                    if (point.type === 'start') {
                        if (point.rangeType === 'figurative') activeFigurative = point.data;
                        if (point.rangeType === 'search') activeSearch = true;
                    } else {
                        // End point
                        if (point.rangeType === 'figurative') activeFigurative = null;
                        if (point.rangeType === 'search') activeSearch = false;
                    }

                    lastIdx = point.idx;
                }

                // Trailing text
                if (lastIdx < html.length) {
                    result += html.substring(lastIdx);
                }

                return result;
            }
        }

        function createFigurativeTag(content, annotation) {
            const visibleTypes = annotation.types || [];
            if (visibleTypes.length === 0) return content;

            const typeIndicators = visibleTypes.map(type => {
                const typeDisplayName = type.charAt(0).toUpperCase() + type.slice(1);
                return `<span class="type-indicator"><span class="type-color-square ${type}"></span>${typeDisplayName}</span>`;
            }).join('');

            const tooltip = `<div class="type-tooltip">${typeIndicators}</div>`;

            // Minimal Annotation for data attribute
            const minimalAnnotation = {
                verse_id: annotation.verse_id,
                verse_reference: annotation.verse_reference,
                figurative_text: annotation.figurative_text,
                types: annotation.types,
                target: annotation.target,
                vehicle: annotation.vehicle,
                ground: annotation.ground,
                posture: annotation.posture,
                speaker: annotation.speaker,
                confidence: annotation.confidence
            };

            const escapedJson = JSON.stringify(minimalAnnotation)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;');

            return `<span class="figurative-highlight" data-annotation='${escapedJson}'>${content}${tooltip}</span>`;
        }

        // Clean Hebrew Helper (kept for compatibility if referenced elsewhere, but normalized)
        function cleanHebrewText(text) {
            // Just basic HTML cleanup for display if needed
            if (!text) return '';
            return text.replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ').trim();
        }

        function renderVerses() {
            if (appState.filteredVerses.length === 0) {
                elements.versesContainer.innerHTML = '<div class="loading"><p>No verses match your current filters.</p></div>';
                return;
            }

            const versesHTML = appState.filteredVerses.map(verse => {
                // 1. Get Base HTML
                let hebrewHtml = appState.textVersion === 'sacred' ? verse.hebrew_text : verse.hebrew_text_non_sacred;
                if (!hebrewHtml) hebrewHtml = '[Hebrew text unavailable]';

                let englishHtml = appState.textVersion === 'sacred' ? verse.english_text_clean : verse.english_text_clean_non_sacred;
                englishHtml = removeFootnotes(englishHtml);

                // 2. Prepare Annotations
                const annotations = verse.annotations.map(annotation => ({
                    ...annotation,
                    verse_reference: verse.reference,
                    verse_id: verse.id,
                    verse_deliberation: verse.figurative_detection_deliberation,
                    verse_model_used: verse.model_used
                }));

                // 3. Highlight Hebrew
                const hebrewRanges = TextHighlighter.findRanges(hebrewHtml, annotations, appState.searchType === 'hebrew' ? appState.currentSearch.text : null, 'hebrew');
                const processedHebrew = TextHighlighter.applyHighlights(hebrewHtml, hebrewRanges);

                // 4. Highlight English
                const englishRanges = TextHighlighter.findRanges(englishHtml, annotations, appState.searchType === 'english' ? appState.currentSearch.text : null, 'english');
                const processedEnglish = TextHighlighter.applyHighlights(englishHtml, englishRanges);

                return `
                    <div class="verse-container">
                        <div class="verse-header" onclick="showVerseDetails('${verse.reference}', ${verse.id})">
                            ${verse.reference}
                        </div>
                        <div class="verse-content">
                            <div class="english-text">${processedEnglish}</div>
                            <div class="hebrew-text">${processedHebrew}</div>
                        </div>
                    </div>
                `;
            }).join('');

            elements.versesContainer.innerHTML = versesHTML;

            // Add click listeners
            document.querySelectorAll('.figurative-highlight').forEach(element => {
                element.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const annotation = JSON.parse(this.dataset.annotation);
                    showAnnotationDetails(annotation);
                });
            });
        }

        function updateDeliberationDisplay(verse) {
            if (!verse) return;

            const deliberation = appState.textVersion === 'sacred'
                ? verse.figurative_detection_deliberation
                : verse.figurative_detection_deliberation_non_sacred;

            elements.deliberationText.innerHTML = formatDeliberationText(deliberation);
        }

        function formatDeliberationText(text) {
            if (!text) return '';

            // Convert markdown-style formatting to HTML
            let formatted = text;

            // Replace **bold** with spans
            formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<span class="deliberation-bold">$1</span>');

            // Replace *italic* with spans (but not part of **)
            formatted = formatted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span class="deliberation-italic">$1</span>');

            // Replace common labels with styled versions - and add paragraph breaks before them
            formatted = formatted.replace(/\s*<span class="deliberation-label">Phrase\/Concept:<\/span>/g, '<br><br><span class="deliberation-label">Phrase/Concept:</span>');
            formatted = formatted.replace(/\s*<span class="deliberation-label">Considered:<\/span>/g, '<br><br><span class="deliberation-label">Considered:</span>');
            formatted = formatted.replace(/\s*<span class="deliberation-label">Reasoning for (including|excluding):<\/span>/g, '<br><br><span class="deliberation-label">Reasoning for $1:</span>');

            // Also handle the original pattern replacement
            formatted = formatted.replace(/\*\*Phrase\/Concept:\*\*/g, '<br><br><span class="deliberation-label">Phrase/Concept:</span>');
            formatted = formatted.replace(/\*\*Considered:\*\*/g, '<br><br><span class="deliberation-label">Considered:</span>');
            formatted = formatted.replace(/\*\*Reasoning for (including|excluding):\*\*/g, '<br><br><span class="deliberation-label">Reasoning for $1:</span>');

            // Split into numbered items
            const lines = formatted.split(/(?=\d+\.\s+(?:\*\*|<span))/);

            if (lines.length > 1) {
                // Has numbered items - format them
                return lines.map(line => {
                    const match = line.match(/^(\d+)\.\s+(.+)$/s);
                    if (match) {
                        const [, num, content] = match;
                        // Remove leading <br> tags from the start of content
                        const cleanContent = content.trim().replace(/^(?:<br>)+/, '');
                        return `<div class="deliberation-item"><span class="deliberation-number">${num}.</span> ${cleanContent}</div>`;
                    }
                    return line.trim() ? `<div>${line.trim()}</div>` : '';
                }).filter(Boolean).join('');
            }

            return formatted;
        }

        function showVerseDetails(reference, verseId) {
            // Check if panel is already open for THIS verse - if so, close it
            if (elements.detailPanel.classList.contains('active') &&
                elements.selectedVerse.textContent === reference &&
                !elements.detailPanel.classList.contains('annotation-details')) {
                closeDetailPanel();
                return;
            }

            const verse = appState.verses.find(v => v.id === verseId);
            if (!verse) return;

            elements.selectedVerse.textContent = reference;
            updateDeliberationDisplay(verse);
            elements.modelUsed.textContent = verse.model_used;

            // Clear any previous annotation details when showing verse details
            elements.annotationDetails.innerHTML = '';

            // Remove annotation-details class and use regular panel
            elements.detailPanel.classList.remove('annotation-details');
            elements.detailPanel.classList.add('active');

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open-large');
            mainContent.classList.add('panel-open');
        }

        function showAnnotationDetails(minimalAnnotation) {
            // Find the full annotation data from appState.verses
            const verse = appState.verses.find(v => v.id === minimalAnnotation.verse_id);
            let fullAnnotation = minimalAnnotation;

            if (verse) {
                // Find the full annotation that matches this minimal one
                fullAnnotation = verse.annotations.find(ann =>
                    ann.figurative_text === minimalAnnotation.figurative_text &&
                    JSON.stringify(ann.types) === JSON.stringify(minimalAnnotation.types)
                ) || minimalAnnotation;

                // Update verse deliberation
                elements.selectedVerse.textContent = verse.reference;
                updateDeliberationDisplay(verse);
                elements.modelUsed.textContent = verse.model_used || 'Unknown';
            }

            // Format validation reasons using fullAnnotation
            const validationReasons = [];
            if (fullAnnotation.validation_reason_metaphor) validationReasons.push(`Metaphor: ${fullAnnotation.validation_reason_metaphor}`);
            if (fullAnnotation.validation_reason_simile) validationReasons.push(`Simile: ${fullAnnotation.validation_reason_simile}`);
            if (fullAnnotation.validation_reason_personification) validationReasons.push(`Personification: ${fullAnnotation.validation_reason_personification}`);
            if (fullAnnotation.validation_reason_idiom) validationReasons.push(`Idiom: ${fullAnnotation.validation_reason_idiom}`);
            if (fullAnnotation.validation_reason_hyperbole) validationReasons.push(`Hyperbole: ${fullAnnotation.validation_reason_hyperbole}`);
            if (fullAnnotation.validation_reason_metonymy) validationReasons.push(`Metonymy: ${fullAnnotation.validation_reason_metonymy}`);
            if (fullAnnotation.validation_reason_other) validationReasons.push(`Other: ${fullAnnotation.validation_reason_other}`);

            const validationHTML = validationReasons.length > 0 ?
                `<div style="margin-bottom: 1rem;">
                    <strong>Validation Reasons:</strong>
                    <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        ${validationReasons.map(reason => `<li>${reason}</li>`).join('')}
                    </ul>
                </div>` : '';

            // Get Hebrew and English phrases (respect non-sacred setting)
            const useNonSacred = appState.textVersion === 'non-sacred';
            const hebrewPhrase = useNonSacred ?
                (fullAnnotation.figurative_text_in_hebrew_non_sacred || fullAnnotation.figurative_text_in_hebrew) :
                fullAnnotation.figurative_text_in_hebrew;
            const englishPhrase = useNonSacred ?
                (fullAnnotation.figurative_text_non_sacred || fullAnnotation.figurative_text) :
                fullAnnotation.figurative_text;

            // Create type badges
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };
            const typeBadges = fullAnnotation.types.map(type =>
                `<span class="type-indicator ${type}">${typeLabels[type]}</span>`
            ).join('');

            const detailsHTML = `
                <h4 style="color: var(--accent-color); margin-bottom: 1rem;">Annotation Details</h4>

                <div class="annotation-phrase">
                    <div class="annotation-phrase-hebrew">${hebrewPhrase || ''}</div>
                    <div class="annotation-phrase-english">${englishPhrase || ''}</div>
                </div>

                <div class="type-badges">
                    ${typeBadges}
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <strong>Target:</strong><br>
                        <small>${Array.isArray(fullAnnotation.target) ? fullAnnotation.target.join(' → ') : (fullAnnotation.target || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Vehicle:</strong><br>
                        <small>${Array.isArray(fullAnnotation.vehicle) ? fullAnnotation.vehicle.join(' → ') : (fullAnnotation.vehicle || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Ground:</strong><br>
                        <small>${Array.isArray(fullAnnotation.ground) ? fullAnnotation.ground.join(' → ') : (fullAnnotation.ground || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Posture:</strong><br>
                        <small>${Array.isArray(fullAnnotation.posture) ? fullAnnotation.posture.join(' → ') : (fullAnnotation.posture || 'N/A')}</small>
                    </div>
                </div>

                <div style="margin-bottom: 1rem;">
                    <strong>Explanation:</strong><br>
                    <p style="margin-top: 0.5rem;">${fullAnnotation.explanation || 'No explanation available'}</p>
                </div>

                ${validationHTML}

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div><strong>Speaker:</strong> ${fullAnnotation.speaker || 'N/A'}</div>
                    <div><strong>Confidence:</strong> ${fullAnnotation.confidence ? (fullAnnotation.confidence * 100).toFixed(1) + '%' : 'N/A'}</div>
                </div>
            `;

            elements.annotationDetails.innerHTML = detailsHTML;
            elements.detailPanel.classList.add('active', 'annotation-details');

            // Remove previous panel classes and add large panel class
            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open');
            mainContent.classList.add('panel-open-large');
        }

        function closeDetailPanel() {
            elements.detailPanel.classList.remove('active', 'annotation-details');
            elements.annotationDetails.innerHTML = '';

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open', 'panel-open-large');
        }

        async function updateStats() {
            const currentVerses = appState.verses.length;
            const totalAnnotations = appState.verses.reduce((sum, verse) => sum + verse.annotations.length, 0);
            const totalCount = appState.pagination.total;
            const totalFigurativeInstances = appState.pagination.total_figurative_instances || 0;

            // Calculate how many verses remain to be loaded
            const remainingVerses = totalCount - currentVerses;

            // Estimate next batch size based on remaining verses
            let estimatedNextBatch = Math.min(appState.pagination.limit, remainingVerses);

            const nextButton = appState.pagination.hasMore ?
                `<button class="nav-button" onclick="loadMore()">Load Next ${estimatedNextBatch} Verses</button>` :
                '<span style="color: #28a745; font-weight: 600;">✓ All verses loaded</span>';

            // Check if we're showing an estimate
            if (appState.pagination.countIsEstimate) {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances)
                        <span style="color: #6c757d; font-style: italic;">(calculating total...)</span>
                    </div>
                    <div>${nextButton}</div>
                `;
            } else {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances) of ${totalCount.toLocaleString()} verses (${totalFigurativeInstances.toLocaleString()} figurative language instances)
                    </div>
                    <div>${nextButton}</div>
                `;
            }
        }

        async function loadMore() {
            if (appState.pagination.hasMore && !appState.loading) {
                // Increment request counter to track this specific request
                appState.requestCounter++;
                const thisRequestId = appState.requestCounter;

                const params = buildAPIParams();
                params.offset = appState.pagination.offset + appState.pagination.limit;

                appState.loading = true;
                try {
                    const data = await makeAPICall('/verses', params);

                    // Only process results if this is still the most recent request
                    if (thisRequestId === appState.requestCounter && data) {
                        appState.verses = [...appState.verses, ...data.verses];
                        // Preserve total and total_figurative_instances from initial load (may have been updated by background count)
                        const preservedTotal = appState.pagination.total;
                        const preservedFigurativeInstances = appState.pagination.total_figurative_instances;
                        // Convert API response to frontend format
                        appState.pagination = {
                            ...data.pagination,
                            hasMore: data.pagination.has_more, // Convert snake_case to camelCase
                            total: preservedTotal || data.pagination.total,
                            total_figurative_instances: preservedFigurativeInstances || data.pagination.total_figurative_instances
                        };
                        appState.filteredVerses = appState.verses;
                        renderVerses();
                        updateStats();
                    } else if (thisRequestId !== appState.requestCounter) {
                        console.log(`Ignoring stale loadMore response (request ${thisRequestId}, current ${appState.requestCounter})`);
                    }
                } catch (error) {
                    if (thisRequestId === appState.requestCounter) {
                        console.error('Failed to load more verses:', error);
                    }
                } finally {
                    if (thisRequestId === appState.requestCounter) {
                        appState.loading = false;
                    }
                }
            }
        }

        async function loadVerses() {
            // Default to 'all' if inputs are empty
            const chapterInput = document.getElementById('chapter-input');
            const verseInput = document.getElementById('verse-input');

            if (!chapterInput.value.trim()) {
                chapterInput.value = 'all';
            }
            if (!verseInput.value.trim()) {
                verseInput.value = 'all';
            }

            // Reset pagination and load fresh data
            appState.pagination.offset = 0;
            const params = buildAPIParams();
            await loadVersesFromAPI(params);
        }
    </script>
    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeSidebar()"></div>

    <script>
        // Mobile Sidebar Toggle
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');

            // Toggle display based on active class for overlay
            if (overlay.classList.contains('active')) {
                overlay.style.display = 'block';
            } else {
                setTimeout(() => {
                    if (!overlay.classList.contains('active')) overlay.style.display = 'none';
                }, 300); // Wait for opacity transition
            }
        }

        function closeSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }

        // Close details panel when clicking outside on mobile
        document.addEventListener('click', function (event) {
            const detailPanel = document.querySelector('.detail-panel');
            const isClickInside = detailPanel.contains(event.target);
            const isVerseHeader = event.target.closest('.verse-header');
            // If panel is active and click is outside, and we are on mobile
            if (detailPanel.classList.contains('active') && !isClickInside && !isVerseHeader && window.innerWidth <= 768) {
                closeDetailPanel();
            }
        });
    </script>
</body>

</html>