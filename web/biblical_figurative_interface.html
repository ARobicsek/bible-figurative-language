<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tzafun</title>
    <style>
        /* Hebrew Font Support */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;600&family=Crimson+Text:wght@400;600&display=swap');

        :root {
            /* Figurative Language Colors - Elegant but distinct palette */
            --metaphor-color: #a0695f;
            --simile-color: #5a8ca8;
            --personification-color: #9370a8;
            --idiom-color: #c9a255;
            --hyperbole-color: #c17a61;
            --metonymy-color: #5d9b82;
            --other-color: #7a8896;

            /* Layout Colors */
            --sidebar-bg: #f8f9fa;
            --main-bg: #ffffff;
            --border-color: #dee2e6;
            --text-color: #212529;
            --accent-color: #007bff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--main-bg);
        }

        /* Main Layout Grid */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
            max-height: 100vh;
            position: relative;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #0a1930 0%, #020408 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            flex: 1;
        }

        .header h1 {
            font-size: 2.07rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.3rem;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .header-hebrew-quote {
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 1.048rem !important;
            opacity: 0.9;
            direction: ltr;
            text-align: left;
            line-height: 1;
        }

        .header-attribution {
            font-size: 1.3rem;
            color: white;
            opacity: 0.9;
            text-align: right;
            line-height: 1.4;
            max-width: 350px;
        }

        .header-attribution a {
            color: white;
            text-decoration: none;
            cursor: pointer;
            font-weight: 600;
            /* Bolder */
            display: inline-block;
            transition: opacity 0.2s;
        }

        .header-attribution a:hover {
            text-decoration: underline;
            opacity: 1;
        }

        .header h1 {
            cursor: pointer;
        }

        .header h1:hover {
            opacity: 0.8;
        }

        /* About Page Styles */
        .about-page {
            display: none;
            overflow-y: auto;
            height: calc(100vh - 120px);
            grid-column: 1 / -1;
        }

        .about-page.active {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
        }

        .about-toc {
            padding: 2rem 1.5rem;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            position: sticky;
            top: 0;
            height: fit-content;
        }

        .about-toc h3 {
            font-size: 1rem;
            color: #2b394f;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #2b394f;
        }

        .about-toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .about-toc li {
            margin-bottom: 0.75rem;
        }

        .about-toc a {
            color: #495057;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s;
        }

        .about-toc a:hover {
            color: #2b394f;
            text-decoration: underline;
        }

        .about-content {
            padding: 2rem;
            max-width: 900px;
        }

        .about-page h2 {
            font-size: 1.8rem;
            color: #2b394f;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #2b394f;
            padding-bottom: 0.5rem;
        }

        .about-page h2:first-child {
            margin-top: 0;
        }

        .about-page p {
            margin-bottom: 0.5rem;
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .about-page strong {
            font-weight: 600;
            color: #2b394f;
            font-size: 1.3em;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 20px;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Sidebar */
        .sidebar {
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        .sidebar section {
            margin-bottom: 2rem;
        }

        .sidebar h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2b394f;
            border-bottom: 2px solid #2b394f;
            padding-bottom: 0.3rem;
            width: fit-content;
            /* Fixes underline length */
        }

        .sidebar h3.tooltip {
            display: block;
        }

        .sidebar label {
            display: block;
            margin-bottom: 0.5rem;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .sidebar input,
        .sidebar select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .sidebar input[type="checkbox"],
        .sidebar input[type="radio"] {
            width: auto;
            margin-right: 0.5rem;
            margin-bottom: 0;
        }

        /* New Control Classes (Refactored from inline styles) */
        .control-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .control-header.mt {
            margin-top: 0.75rem;
        }

        .control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .control-link {
            background: none;
            border: none;
            color: #007bff;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 2px 4px;
            margin: 0;
            text-decoration: none;
            transition: color 0.2s;
        }

        .control-link:hover {
            text-decoration: underline;
            color: #0056b3;
        }

        .control-separator {
            color: #dee2e6;
            /* Lighter color for separator */
        }

        .refresh-btn {
            background: none;
            border: none;
            color: #6c757d;
            font-size: 1.1rem;
            cursor: pointer;
            padding: 4px;
            margin: 0;
            line-height: 1;
            transition: color 0.2s, transform 0.2s;
            border-radius: 4px;
        }

        .refresh-btn:hover {
            color: #2b394f;
            background-color: #e9ecef;
            transform: rotate(30deg);
        }

        .load-btn {
            width: 100%;
            padding: 0.6rem;
            background: #2b394f;
            color: white;
            border: 1px solid #2b394f;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 0.75rem;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 1rem;
        }

        .load-btn:hover {
            background: #1a2533;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        /* Type Filter Colors */
        .type-filters label {
            position: relative;
            padding-left: 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .type-filters input[type="checkbox"] {
            position: relative;
            z-index: 2;
            margin-right: 0;
        }

        .type-filters input[type="checkbox"]:checked+.filter-color {
            opacity: 1;
        }

        .filter-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            opacity: 0.4;
            border: 1px solid rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .filter-color.metaphor {
            background-color: var(--metaphor-color);
        }

        .filter-color.simile {
            background-color: var(--simile-color);
        }

        .filter-color.personification {
            background-color: var(--personification-color);
        }

        .filter-color.idiom {
            background-color: var(--idiom-color);
        }

        .filter-color.hyperbole {
            background-color: var(--hyperbole-color);
        }

        .filter-color.metonymy {
            background-color: var(--metonymy-color);
        }

        .filter-color.other {
            background-color: var(--other-color);
        }

        /* Main Content Area */
        .main-content {
            padding: 1.5rem;
            padding-bottom: 120px;
            /* Space for fixed stats bar */
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        /* Verse Container */
        .verse-container {
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: box-shadow 0.2s ease;
        }

        .verse-container:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .verse-header {
            background-color: #f8f9fa;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
        }

        .verse-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 1.5rem;
            position: relative;
            align-items: center;
            /* Vertically center the text blocks */
        }

        /* Text Columns */
        .english-text {
            font-size: 1.1rem;
            line-height: 1.8;
            position: relative;
            padding-bottom: 1rem;
        }

        .hebrew-text {
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 1.3rem;
            line-height: 1.8;
            direction: rtl;
            text-align: right;
            position: relative;
            padding-bottom: 1rem;
        }

        /* Old annotation CSS removed - using simple highlighting approach */

        /* Simple Figurative Text Highlighting */
        .figurative-highlight {
            background-color: #fff3cd;
            /* Light yellow highlighting */
            padding: 1px 2px;
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .figurative-highlight:hover {
            background-color: #ffeaa7;
            /* Slightly more yellow on hover */
        }

        /* Tooltip for showing figurative types */
        .type-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            margin-bottom: 5px;
        }

        .type-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .figurative-highlight:hover .type-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Type indicator squares in tooltip */
        .type-indicator {
            display: inline-flex;
            align-items: center;
            margin-right: 8px;
        }

        .type-indicator:last-child {
            margin-right: 0;
        }

        .type-color-square {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
            display: inline-block;
        }

        .type-color-square.metaphor {
            background-color: var(--metaphor-color);
        }

        .type-color-square.simile {
            background-color: var(--simile-color);
        }

        .type-color-square.personification {
            background-color: var(--personification-color);
        }

        .type-color-square.idiom {
            background-color: var(--idiom-color);
        }

        .type-color-square.hyperbole {
            background-color: var(--hyperbole-color);
        }

        .type-color-square.metonymy {
            background-color: var(--metonymy-color);
        }

        .type-color-square.other {
            background-color: var(--other-color);
        }

        /* Old annotation line CSS removed */

        /* Bottom Detail Panel */
        .detail-panel {
            position: fixed;
            bottom: 0;
            left: 300px;
            right: 0;
            background-color: white;
            border-top: 1px solid var(--border-color);
            padding: 1.5rem;
            max-height: 40vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .detail-panel.active {
            transform: translateY(0);
        }

        /* Larger panel for annotation details */
        .detail-panel.annotation-details {
            max-height: 60vh;
        }

        /* Adjust main content when panel is open */
        .main-content.panel-open {
            padding-bottom: 40vh;
        }

        .main-content.panel-open-large {
            padding-bottom: 60vh;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header h3 {
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0.25rem;
        }

        .close-btn:hover {
            color: var(--text-color);
        }

        .annotation-details:not(:empty) {
            border: 1px solid var(--border-color);
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
        }

        .annotation-phrase {
            display: grid;
            grid-template-columns: 1fr 2px 1fr;
            gap: 10px;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
        }

        .annotation-phrase::after {
            content: '';
            grid-column: 2;
            width: 1px;
            height: 100%;
            background-color: #999;
            justify-self: center;
        }

        .annotation-phrase-hebrew {
            grid-column: 1;
            direction: rtl;
            text-align: right;
            font-family: 'Noto Sans Hebrew', serif;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .annotation-phrase-english {
            grid-column: 3;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .type-badges {
            margin-bottom: 1rem;
        }

        .type-indicator {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: 500;
            color: white;
        }

        .type-indicator.metaphor {
            background-color: var(--metaphor-color);
        }

        .type-indicator.simile {
            background-color: var(--simile-color);
        }

        .type-indicator.personification {
            background-color: var(--personification-color);
        }

        .type-indicator.idiom {
            background-color: var(--idiom-color);
        }

        .type-indicator.hyperbole {
            background-color: var(--hyperbole-color);
        }

        .type-indicator.metonymy {
            background-color: var(--metonymy-color);
        }

        .type-indicator.other {
            background-color: var(--other-color);
        }

        .deliberation-section {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f9f9f9;
            border-left: 3px solid var(--accent-color);
            border-radius: 0 4px 4px 0;
        }

        .deliberation-section h4 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }

        #deliberation-text {
            line-height: 1.8;
            white-space: pre-wrap;
            font-size: 0.95rem;
        }

        #deliberation-text .deliberation-item {
            margin-bottom: 1.2rem;
            padding-left: 1.5rem;
            text-indent: -1.5rem;
        }

        #deliberation-text .deliberation-number {
            font-weight: 600;
            color: var(--accent-color);
            margin-right: 0.5rem;
        }

        #deliberation-text .deliberation-bold {
            font-weight: 600;
            color: var(--text-color);
        }

        #deliberation-text .deliberation-italic {
            font-style: italic;
            color: #555;
        }

        #deliberation-text .deliberation-label {
            font-weight: 600;
            color: var(--accent-color);
        }

        .model-badge {
            display: inline-block;
            background-color: #e9ecef;
            color: #495057;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
        }

        .spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .sidebar {
                max-height: none;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .verse-content {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .hebrew-text {
                order: -1;
            }

            .detail-panel {
                left: 0;
                max-height: 50vh;
            }

            .main-content.panel-open {
                padding-bottom: 50vh;
            }
        }

        /* Search Highlighting - pink for search matches */
        .search-highlight {
            background-color: #ffb3d9;
            font-weight: 600;
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* When search highlight is inside figurative highlight, pink takes priority */
        .figurative-highlight .search-highlight {
            background-color: #ffb3d9;
            box-shadow: 0 0 0 2px #fff3cd;
            /* Yellow border to show it's also figurative */
        }

        /* Stats Bar */
        .stats-bar {
            background-color: #f8f9fa;
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.95rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 100;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        .stats-text {
            flex: 1;
        }

        .nav-button {
            background: linear-gradient(135deg, #0a1930 0%, #2b394f 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .nav-button:hover {
            background: linear-gradient(135deg, #2b394f 0%, #0a1930 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Hebrew Keyboard Styles */
        .search-type-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #2b394f;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            color: #2b394f;
        }

        .toggle-btn:hover {
            background-color: #f8f9fa;
        }

        .toggle-btn.active {
            background-color: #2b394f;
            color: white;
            border-color: #2b394f;
        }

        .hebrew-keyboard {
            display: none;
            grid-template-columns: repeat(9, 1fr);
            gap: 0.15rem;
            margin: 0.5rem 0;
            padding: 0.4rem;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .hebrew-keyboard.active {
            display: grid;
        }

        .hebrew-key {
            padding: 0.3rem 0.2rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            text-align: center;
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 0.9rem;
            transition: background-color 0.1s ease;
            min-height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hebrew-key:hover {
            background-color: #e9ecef;
        }

        .hebrew-key.wide {
            grid-column: span 2;
        }

        .hebrew-key.action {
            font-size: 0.75rem;
            font-family: 'Crimson Text', serif;
        }

        .search-input-container {
            position: relative;
            margin-bottom: 0.5rem;
        }

        .keyboard-toggle {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #2b394f;
            cursor: pointer;
            font-size: 1rem;
            color: #2b394f;
            border-radius: 3px;
            padding: 2px 6px;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .keyboard-toggle:hover {
            background-color: #f8f9fa;
        }

        /* Ensure keyboard doesn't overlap with search input */
        #search-input {
            margin-bottom: 0;
            padding-right: 4rem;
            /* Make room for both keyboard and clear buttons */
        }

        .clear-search-btn {
            position: absolute;
            right: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #6c757d;
            cursor: pointer;
            font-size: 1rem;
            color: #6c757d;
            border-radius: 3px;
            padding: 3px 6px;
            transition: all 0.2s ease;
            z-index: 1;
            display: none;
        }

        .clear-search-btn.active {
            display: block;
        }

        .clear-search-btn:hover {
            background-color: #6c757d;
            color: white;
        }

        /* Clear Metadata Button hover effect removed (handled by .refresh-btn) */
        /* #clear-metadata-btn:hover { ... } removed */

        /* Search Highlight (Underline/Border to coexist with figurative background) */
        .search-highlight {
            background-color: transparent;
            border-bottom: 3px solid #ffb3d9;
            font-weight: 600;
        }

        /* Print Styles */
        @media print {

            /* Hide non-print elements */
            .sidebar,
            .header,
            .stats-bar,
            .detail-panel,
            .navigation,
            .about-page {
                display: none !important;
            }

            /* Reset layout for print */
            .app-container {
                display: block;
                max-height: none;
            }

            .main-content {
                padding: 0;
                max-height: none;
                overflow: visible;
            }

            /* Print header section */
            .print-header {
                display: block !important;
                padding: 20px;
                border-bottom: 2px solid #000;
                margin-bottom: 30px;
                page-break-after: avoid;
            }

            .print-header h1 {
                font-size: 34pt;
                margin-bottom: 10px;
                color: #000;
            }

            .print-header h2 {
                font-size: 23pt;
                margin-top: 15px;
                margin-bottom: 8px;
                color: #000;
                border-bottom: 1px solid #666;
                padding-bottom: 3px;
            }

            .print-header p {
                font-size: 15pt;
                margin: 3px 0;
                line-height: 1.4;
            }

            .print-header .filter-summary {
                margin-top: 10px;
            }

            /* Verse containers for print */
            .verse-container {
                page-break-inside: avoid;
                margin-bottom: 30px;
                border: 1px solid #000;
                padding: 15px;
            }

            .verse-header {
                font-size: 20pt;
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #333;
                background-color: transparent;
            }

            .verse-content {
                display: block;
                padding: 0;
            }

            /* Hide the original Hebrew/English text in print (we show them at top in verse-text-columns) */
            .verse-content>.hebrew-text,
            .verse-content>.english-text {
                display: none !important;
            }

            /* Text columns at top */
            .verse-text-columns {
                display: grid !important;
                grid-template-columns: 1fr 2px 1fr;
                gap: 15px;
                padding: 15px 0;
                margin-bottom: 20px;
                align-items: start;
                border-bottom: 1px solid #ddd;
            }

            .verse-text-columns::after {
                content: '';
                grid-column: 2;
                width: 1px;
                height: 100%;
                background-color: #999;
                justify-self: center;
            }

            .hebrew-text {
                grid-column: 1;
                font-size: 15pt;
                line-height: 1.6;
                direction: rtl;
                text-align: right;
            }

            .english-text {
                grid-column: 3;
                font-size: 15pt;
                line-height: 1.6;
            }

            /* Preserve highlighting in print */
            .figurative-highlight {
                background-color: #ffeb3b !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                padding: 2px;
            }

            .search-highlight {
                background-color: #ffb3d9 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Print-specific sections */
            .print-deliberation {
                display: block !important;
                margin: 15px 0;
                padding: 15px;
                background-color: #f9f9f9 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                border-left: 3px solid #007bff;
                page-break-inside: avoid;
                grid-column: 1 / -1;
            }

            .print-deliberation h4 {
                font-size: 18pt;
                margin-bottom: 12px;
                color: #007bff;
                font-weight: 600;
            }

            .print-deliberation .deliberation-content {
                font-size: 14pt;
                line-height: 1.8;
                white-space: pre-wrap;
            }

            .print-deliberation .deliberation-item {
                display: block;
                margin-bottom: 20px;
                padding-left: 15px;
                text-indent: -15px;
                page-break-inside: avoid;
            }

            .print-deliberation .deliberation-item:last-child {
                margin-bottom: 0;
            }

            .print-deliberation .deliberation-number {
                font-weight: 600;
                color: #007bff;
                margin-right: 5px;
            }

            .print-deliberation .deliberation-bold {
                font-weight: 600;
                color: #000;
            }

            .print-deliberation .deliberation-italic {
                font-style: italic;
                color: #555;
            }

            .print-deliberation .deliberation-label {
                font-weight: 600;
                color: #007bff;
            }

            .print-deliberation .model-badge {
                display: inline-block;
                background-color: #e9ecef !important;
                color: #495057 !important;
                padding: 3px 8px;
                border-radius: 3px;
                font-size: 13pt;
                font-weight: 600;
                margin-left: 8px;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .print-annotation {
                display: block !important;
                margin: 15px 0;
                padding: 10px;
                border: 1px solid #999;
                page-break-inside: avoid;
                grid-column: 1 / -1;
            }

            .print-annotation h5 {
                font-size: 15pt;
                margin-bottom: 8px;
                color: #000;
            }

            .print-annotation p {
                font-size: 14pt;
                line-height: 1.4;
                margin: 4px 0;
            }

            .print-annotation .annotation-phrase {
                display: grid;
                grid-template-columns: 1fr 2px 1fr;
                gap: 10px;
                margin-bottom: 12px;
                padding-bottom: 12px;
                border-bottom: 1px solid #ddd;
                align-items: center;
            }

            .print-annotation .annotation-phrase::after {
                content: '';
                grid-column: 2;
                width: 1px;
                height: 100%;
                background-color: #999;
                justify-self: center;
            }

            .print-annotation .annotation-phrase-hebrew {
                grid-column: 1;
                direction: rtl;
                text-align: right;
                font-family: 'Noto Sans Hebrew', serif;
                font-weight: bold;
                font-size: 15pt;
            }

            .print-annotation .annotation-phrase-english {
                grid-column: 3;
                font-weight: bold;
                font-size: 15pt;
            }

            .print-annotation .type-indicator {
                display: inline-block;
                margin-right: 8px;
                padding: 2px 6px;
                border: 1px solid #000;
            }

            /* Type color preservation */
            .type-indicator.metaphor {
                background-color: var(--metaphor-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.simile {
                background-color: var(--simile-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.personification {
                background-color: var(--personification-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.idiom {
                background-color: var(--idiom-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.hyperbole {
                background-color: var(--hyperbole-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.metonymy {
                background-color: var(--metonymy-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .type-indicator.other {
                background-color: var(--other-color) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Hide tooltips in print */
            .type-tooltip,
            .tooltiptext {
                display: none !important;
            }

            /* Page breaks */
            .verse-container {
                page-break-inside: avoid;
            }

            h4,
            h5 {
                page-break-after: avoid;
            }
        }

        /* Hide print sections on screen */
        .print-header,
        .print-deliberation,
        .print-annotation,
        .verse-text-columns {
            display: none;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 onclick="showMainPage()">Tzafun</h1>
                <p>A concordance of Biblical figurative language</p>
                <p class="header-hebrew-quote">מה רב־טובך אשר־צפנת ליראיך (Psalms 31:20)</p>
            </div>
            <div class="header-attribution">
                <a onclick="showAboutPage()">about</a><br>
                <a onclick="printPage()">print</a>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Book/Chapter Selection -->
            <section class="book-selection">
                <section class="book-selection">
                    <h3>Text Selection</h3>

                    <!-- Book Selection Controls -->
                    <div class="control-header">
                        <label for="book-select" style="margin-bottom: 0;">Books (Ctrl+Click):</label>
                        <div class="control-group">
                            <button onclick="selectAllBooks()" class="control-link"
                                title="Select all books">All</button>
                            <span class="control-separator">|</span>
                            <button onclick="clearAllBooks()" class="control-link" title="Clear all books">None</button>
                        </div>
                    </div>

                    <select id="book-select" multiple>
                        <!-- Torah -->
                        <option value="genesis" selected>Genesis</option>
                        <option value="exodus" selected>Exodus</option>
                        <option value="leviticus" selected>Leviticus</option>
                        <option value="numbers" selected>Numbers</option>
                        <option value="deuteronomy" selected>Deuteronomy</option>
                        <!-- Nevi'im (Prophets) -->
                        <option value="isaiah" selected>Isaiah</option>
                        <option value="jeremiah" selected>Jeremiah</option>
                        <option value="ezekiel" selected>Ezekiel</option>
                        <option value="hosea" selected>Hosea</option>
                        <option value="joel" selected>Joel</option>
                        <option value="amos" selected>Amos</option>
                        <!-- Ketuvim (Writings) -->
                        <option value="psalms" selected>Psalms</option>
                        <option value="proverbs" selected>Proverbs</option>
                    </select>

                    <!-- Chapters Input -->
                    <div class="control-header mt">
                        <label for="chapter-input" style="margin-bottom: 0;">Chapters:</label>
                        <button onclick="document.getElementById('chapter-input').value='all'; filterAndRenderVerses();"
                            class="refresh-btn" title="Reset to all chapters">↻</button>
                    </div>
                    <input type="text" id="chapter-input" placeholder="e.g., 1,3,5-7 or 'all'">

                    <!-- Verses Input -->
                    <div class="control-header mt">
                        <label for="verse-input" style="margin-bottom: 0;">Verses:</label>
                        <button onclick="document.getElementById('verse-input').value='all'; filterAndRenderVerses();"
                            class="refresh-btn" title="Reset to all verses">↻</button>
                    </div>
                    <input type="text" id="verse-input" placeholder="e.g., 1-5,10,15 or 'all'">

                    <button id="load-verses" class="load-btn">Load Verses</button>
                </section>

                <!-- Figurative Type Filters -->
                <section class="type-filters">
                    <h3>Figurative Language Types</h3>

                    <!-- Select All / Clear All Buttons -->
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                        <button id="select-all-types"
                            style="flex: 1; padding: 0.4rem 0.8rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease;">Select
                            All</button>
                        <button id="clear-all-types"
                            style="flex: 1; padding: 0.4rem 0.8rem; background: white; color: #2b394f; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease;">Clear
                            All</button>
                    </div>

                    <label class="tooltip">
                        <input type="checkbox" value="metaphor" checked>
                        <span class="filter-color metaphor"></span>
                        Metaphor
                        <span class="tooltiptext">A comparison where one thing is said to be another (e.g., "God is my
                            rock")</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="simile" checked>
                        <span class="filter-color simile"></span>
                        Simile
                        <span class="tooltiptext">A comparison using "like" or "as" (e.g., "like a deer pants for
                            water")</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="personification" checked>
                        <span class="filter-color personification"></span>
                        Personification
                        <span class="tooltiptext">Giving human qualities to non-human things (e.g., "the mountains
                            skipped like rams")</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="idiom" checked>
                        <span class="filter-color idiom"></span>
                        Idiom
                        <span class="tooltiptext">A phrase with a meaning different from its literal words (e.g., "fruit
                            of the womb")</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="hyperbole" checked>
                        <span class="filter-color hyperbole"></span>
                        Hyperbole
                        <span class="tooltiptext">Exaggeration for emphasis (e.g., "rivers of tears flow from my
                            eyes")</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="metonymy" checked>
                        <span class="filter-color metonymy"></span>
                        Metonymy
                        <span class="tooltiptext">Using one thing to represent another closely related thing (e.g., "the
                            sword" for war)</span>
                    </label>
                    <label class="tooltip">
                        <input type="checkbox" value="other" checked>
                        <span class="filter-color other"></span>
                        Other
                        <span class="tooltiptext">Other forms of figurative language not fitting the main
                            categories</span>
                    </label>
                    <label>
                        <input type="checkbox" value="not_figurative">
                        <span class="filter-color" style="background-color: #6c757d;"></span>
                        Not Figurative
                    </label>
                </section>

                <!-- Text Version Toggle -->
                <section class="text-options">
                    <h3 class="tooltip">Text Version
                        <span class="tooltiptext">See About section for details</span>
                    </h3>
                    <div>
                        <label><input type="radio" name="text-version" value="sacred" checked> Sacred Names</label>
                        <label><input type="radio" name="text-version" value="non-sacred"> Traditional Jewish</label>
                    </div>
                </section>

                <!-- Advanced Search -->
                <section class="advanced-search">
                    <h3>Search Biblical Text</h3>

                    <!-- Search Type Toggle -->
                    <div class="search-type-toggle">
                        <button class="toggle-btn active" id="english-toggle"
                            onclick="toggleSearchType('english')">English</button>
                        <button class="toggle-btn" id="hebrew-toggle"
                            onclick="toggleSearchType('hebrew')">עברית</button>
                    </div>

                    <!-- Search Input with Clear and Keyboard Toggle -->
                    <div class="search-input-container">
                        <input type="text" id="search-input" placeholder="Search English text...">
                        <button class="clear-search-btn" id="clear-search-btn" onclick="clearTextSearch()"
                            title="Clear Search">↻</button>
                        <button class="keyboard-toggle" id="keyboard-toggle" onclick="toggleHebrewKeyboard()"
                            title="Toggle Hebrew Keyboard">⌨</button>
                    </div>

                    <!-- Hebrew Virtual Keyboard - Compact rectangular layout -->
                    <div class="hebrew-keyboard" id="hebrew-keyboard">
                        <!-- Row 1: 9 letters -->
                        <div class="hebrew-key" onclick="insertHebrew('א')">א</div>
                        <div class="hebrew-key" onclick="insertHebrew('ב')">ב</div>
                        <div class="hebrew-key" onclick="insertHebrew('ג')">ג</div>
                        <div class="hebrew-key" onclick="insertHebrew('ד')">ד</div>
                        <div class="hebrew-key" onclick="insertHebrew('ה')">ה</div>
                        <div class="hebrew-key" onclick="insertHebrew('ו')">ו</div>
                        <div class="hebrew-key" onclick="insertHebrew('ז')">ז</div>
                        <div class="hebrew-key" onclick="insertHebrew('ח')">ח</div>
                        <div class="hebrew-key" onclick="insertHebrew('ט')">ט</div>
                        <!-- Row 2: 9 letters -->
                        <div class="hebrew-key" onclick="insertHebrew('י')">י</div>
                        <div class="hebrew-key" onclick="insertHebrew('כ')">כ</div>
                        <div class="hebrew-key" onclick="insertHebrew('ל')">ל</div>
                        <div class="hebrew-key" onclick="insertHebrew('מ')">מ</div>
                        <div class="hebrew-key" onclick="insertHebrew('נ')">נ</div>
                        <div class="hebrew-key" onclick="insertHebrew('ס')">ס</div>
                        <div class="hebrew-key" onclick="insertHebrew('ע')">ע</div>
                        <div class="hebrew-key" onclick="insertHebrew('פ')">פ</div>
                        <div class="hebrew-key" onclick="insertHebrew('צ')">צ</div>
                        <!-- Row 3: 9 letters (4 regular + 5 final forms) -->
                        <div class="hebrew-key" onclick="insertHebrew('ק')">ק</div>
                        <div class="hebrew-key" onclick="insertHebrew('ר')">ר</div>
                        <div class="hebrew-key" onclick="insertHebrew('ש')">ש</div>
                        <div class="hebrew-key" onclick="insertHebrew('ת')">ת</div>
                        <div class="hebrew-key" onclick="insertHebrew('ך')">ך</div>
                        <div class="hebrew-key" onclick="insertHebrew('ם')">ם</div>
                        <div class="hebrew-key" onclick="insertHebrew('ן')">ן</div>
                        <div class="hebrew-key" onclick="insertHebrew('ף')">ף</div>
                        <div class="hebrew-key" onclick="insertHebrew('ץ')">ץ</div>
                        <!-- Row 4: Action keys -->
                        <div class="hebrew-key action" onclick="clearSearch()" style="grid-column: span 2;">Clear</div>
                        <div class="hebrew-key" onclick="insertHebrew(' ')" style="grid-column: span 5;">Space</div>
                        <div class="hebrew-key action" onclick="deleteLastChar()" style="grid-column: span 2;">⌫</div>
                    </div>

                    <div
                        style="display: flex; align-items: center; justify-content: space-between; margin-top: 1.5rem; margin-bottom: 0.5rem;">
                        <h4 class="tooltip"
                            style="color: #2b394f; margin: 0; font-size: 1rem; border-bottom: 2px solid #2b394f; padding-bottom: 0.3rem; flex: 1;">
                            Search for Tag
                            <span class="tooltiptext">See About section for details</span>
                        </h4>
                        <button id="clear-metadata-btn" onclick="clearMetadataSearch()" class="refresh-btn"
                            title="Clear tag search">↻</button>
                    </div>
                    <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.5rem; margin-bottom: 0.75rem;">For
                        multiple search terms, separate with semicolons (e.g., "God;Divine")</div>
                    <div class="metadata-search" style="margin-top: 0;">
                        <input type="text" id="target-search" placeholder="Target">
                        <input type="text" id="vehicle-search" placeholder="Vehicle">
                        <input type="text" id="ground-search" placeholder="Ground">
                        <input type="text" id="posture-search" placeholder="Posture">
                    </div>
                </section>
        </aside>

        <!-- Main Content -->
        <main class="main-content" id="main-content">
            <!-- Print Header (hidden on screen, shown when printing) -->
            <div class="print-header" id="print-header">
                <!-- Will be populated by JavaScript when printing -->
            </div>

            <div id="verses-container">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                </div>
            </div>

            <!-- Stats and Navigation Bar at Bottom -->
            <div class="stats-bar" id="stats-bar">
                Loading...
            </div>
        </main>

        <!-- About Page -->
        <div class="about-page" id="about-page">
            <!-- Table of Contents -->
            <div class="about-toc">
                <h3>Contents</h3>
                <ul>
                    <li><a href="#section-tzafun">Tzafun</a></li>
                    <li><a href="#section-information">The information in Tzafun</a></li>
                    <li><a href="#section-sacred">Sacred Names</a></li>
                    <li><a href="#section-documentation">More documentation</a></li>
                    <li><a href="#section-acknowledgements">Acknowledgements</a></li>
                </ul>
            </div>

            <!-- Main Content -->
            <div class="about-content">
                <h2 id="section-tzafun">Tzafun</h2>
                <p>"Tzafun" (צָפֻן) means "hidden" or "concealed" and also implies treasure, as in Psalms 31:20: "How
                    abundant is the good that You have in store (צָפַ֢נְתָּ) for those who fear You" and Psalm 119:11:
                    "I have treasured (צָפַ֣נְתִּי) Your word in my heart."</p>
                <p>The Biblical text is a treasure house of rich figurative language, sometimes clear, sometimes
                    mysterious. It's an essential part of the text's power and eternality. Often, the student's work
                    would benefit from a wide search for some element of figurative speech across a wide corpus of
                    Biblical texts, in the same way as one can search for a particular word or root in a Concordance.
                    Creating a database to enable this would be a great deal of work for humans. Tzafun started with the
                    question: couldn't we use modern Large Language Models (LLMs) to help compile this 'concordance' of
                    biblical figurative speech?</p>
                <p>Tzafun was created by having LLMs "read" the text of the Bible verse by verse, in English and Hebrew,
                    and tag instances of figurative speech, including similes, metaphors, hyperbole, idioms,
                    personification and metonymy.</p>
                <p>This is a two-stage process. A first AI agent reads the verse, deliberates and identifies figurative
                    speech. A second AI agent reviews the work of the first, validating, invalidating or reclassifying
                    the initial tags. Tzafun records the final result, as well as the deliberations of both agents.</p>

                <h2 id="section-information">The information in Tzafun</h2>
                <p><strong>Coverage:</strong> Tzafun currently includes 13 biblical books with over 13,500 verses
                    analyzed:</p>
                <ul style="margin-left: 2rem; margin-bottom: 1rem;">
                    <li><strong>Torah (Pentateuch):</strong> Genesis, Exodus, Leviticus, Numbers, Deuteronomy</li>
                    <li><strong>Wisdom Literature:</strong> Psalms, Proverbs</li>
                    <li><strong>Major Prophets:</strong> Isaiah, Jeremiah, Ezekiel</li>
                    <li><strong>Minor Prophets (Twelve):</strong> Hosea, Joel, Amos</li>
                </ul>
                <p>Each verse is shown in Hebrew (Masoretic) and English (JPS 2006). Examples of figurative speech that
                    were identified by the first agent and validated by the second are highlighted. If you click on the
                    header above any verse, you can see the LLM's deliberations. If you click on a highlighted example
                    of figurative speech, you can also see the following information:</p>
                <p><strong>Target</strong> what or who the figurative speech is about</p>
                <p><strong>Vehicle</strong> what the target is being likened to</p>
                <p><strong>Ground</strong> what quality of the target is being illuminated by the figurative speech</p>
                <p><strong>Posture</strong> purpose of the speech; emotional valence</p>
                <p>Example: "כִּֽי־עָפָ֣ר אַ֔תָּה"/ "For dust you are" (Gen 3:19). Target = humans; Vehicle = dust;
                    Ground = humble origin, ephemerality; Posture = solemn declaration</p>
                <p>To make these easier to search, the LLM was instructed to generate a hierarchy of tags for each of
                    these fields. For example, if the vehicle of the metaphor is bees, the LLM will record "bees →
                    insects → animals". A search for any of these terms will identify Psalms 118:12 "סַבּ֤וּנִי
                    כִדְבוֹרִ֗ים"/ "They have beset me like bees".</p>
                <p><strong>Explanation</strong> The LLM's explanation of the figurative speech.</p>
                <p><strong>Validation reasons</strong> The second agent's deliberations about whether to
                    validate/invalidate/reclassify a phrase tagged by the first agent as figurative speech.</p>
                <p><strong>Speaker</strong> The LLM's assessment of who is speaking the figurative language.</p>
                <p><strong>Confidence</strong> The LLM's level of confidence that this is figurative language.</p>
                <p><strong>Name of the model</strong> Most verses were processed by GPT-5.1, with Claude Opus 4.5 and
                    Gemini 3.0 Pro as fallback models. The model name is shown with each verse's deliberation.</p>

                <h2 id="section-sacred">Sacred Names</h2>
                <p>Traditional Jews who are printing results from Tzafun may wish to avoid printing Divine names that
                    they consider sacred. They can select 'Traditional Jewish' versions of the verses, which replace
                    divine Names with traditional abbreviations.</p>

                <h2 id="section-documentation">More documentation</h2>
                <p>Complete project documentation is available on GitHub at <a
                        href="https://github.com/ARobicsek/bible-figurative-language"
                        target="_blank">github.com/ARobicsek/bible-figurative-language</a></p>

                <h3>Available Documentation:</h3>
                <ul>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/README.md"
                                target="_blank">README</a></strong> - Project overview, installation, and quick start
                        guide</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/METHODOLOGY.md"
                                target="_blank">Methodology</a></strong> - Detailed explanation of the two-stage AI
                        analysis process, model selection, and validation approach</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/DATABASE_SCHEMA.md"
                                target="_blank">Database Schema</a></strong> - Complete database structure and field
                        definitions</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/FEATURES.md"
                                target="_blank">Features Guide</a></strong> - Comprehensive guide to using the web
                        interface</li>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/docs/FAQ.md"
                                target="_blank">FAQ</a></strong> - Frequently asked questions about the project and its
                        data</li>
                    <li><strong><a
                                href="https://github.com/ARobicsek/bible-figurative-language/blob/main/CONTRIBUTING.md"
                                target="_blank">Contributing</a></strong> - How to contribute feedback, report issues,
                        or validate classifications</li>
                    <li><strong><a href="https://github.com/ARobicsek/bible-figurative-language/blob/main/SETUP.md"
                                target="_blank">Setup Guide</a></strong> - Instructions for running Tzafun locally</li>
                </ul>

                <h3>Citation & Licensing:</h3>
                <p>If you use Tzafun in your research or teaching, please cite it appropriately. Citation formats
                    (BibTeX, APA, MLA) and licensing information are available in the <a
                        href="https://github.com/ARobicsek/bible-figurative-language/blob/main/CITATION.cff"
                        target="_blank">CITATION.cff</a> file.</p>
                <ul>
                    <li><strong>Code License:</strong> MIT License - see <a
                            href="https://github.com/ARobicsek/bible-figurative-language/blob/main/LICENSE-CODE.txt"
                            target="_blank">LICENSE-CODE.txt</a></li>
                    <li><strong>Data License:</strong> Creative Commons Attribution 4.0 (CC BY 4.0) - see <a
                            href="https://github.com/ARobicsek/bible-figurative-language/blob/main/LICENSE-DATA.txt"
                            target="_blank">LICENSE-DATA.txt</a></li>
                </ul>

                <h2 id="section-acknowledgements">Acknowledgements</h2>
                <p>Text from Sefaria.org.</p>
                <p>Hebrew: Miqra According to the Masorah (MAM).</p>
                <p>English: Jewish Publication Society, 2006.</p>
                <p>&copy; 2025 Ari Robicsek</p>
            </div>
        </div>

        <!-- Bottom Detail Panel -->
        <div class="detail-panel" id="detail-panel">
            <div class="panel-header">
                <h3>Verse Details: <span id="selected-verse"></span></h3>
                <button class="close-btn" id="close-panel">&times;</button>
            </div>

            <div class="panel-content">
                <div class="annotation-details" id="annotation-details">
                    <!-- Dynamically populated when annotation is clicked -->
                </div>

                <div class="deliberation-section">
                    <h4>Figurative Detection Deliberation</h4>
                    <p id="deliberation-text">Click on a verse to see the AI's deliberation process...</p>
                    <span class="model-badge" id="model-used"></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const appState = {
            verses: [],
            filteredVerses: [],
            selectedTypes: new Set(['metaphor', 'simile', 'personification', 'idiom', 'hyperbole', 'metonymy', 'other']),
            showNotFigurative: false,
            textVersion: 'sacred', // 'sacred' or 'non-sacred' - applies to all text fields
            searchType: 'english', // 'hebrew' or 'english'
            currentSearch: {
                text: '',
                target: '',
                vehicle: '',
                ground: '',
                posture: ''
            },
            pagination: {
                limit: 25,
                offset: 0,
                total: 0,
                hasMore: false,
                total_figurative_instances: 0,
                countIsEstimate: false  // Track if count is an estimate
            },
            loading: false,
            requestCounter: 0,  // Track request order to handle race conditions
            countRequestCounter: 0  // Track background count requests
        };

        // API Configuration - use relative URL to work in both dev and production
        const API_BASE = '/api';

        // Page Navigation Functions
        function showAboutPage() {
            document.getElementById('main-content').style.display = 'none';
            document.querySelector('.sidebar').style.display = 'none';
            document.getElementById('about-page').classList.add('active');
            document.getElementById('about-page').style.gridColumn = '1 / -1';
        }

        function showMainPage() {
            document.getElementById('main-content').style.display = 'block';
            document.querySelector('.sidebar').style.display = 'block';
            document.getElementById('about-page').classList.remove('active');
        }

        // Book Selection Helper Functions
        function selectAllBooks() {
            const bookSelect = document.getElementById('book-select');
            for (let i = 0; i < bookSelect.options.length; i++) {
                bookSelect.options[i].selected = true;
            }
        }

        function clearAllBooks() {
            const bookSelect = document.getElementById('book-select');
            for (let i = 0; i < bookSelect.options.length; i++) {
                bookSelect.options[i].selected = false;
            }
        }

        // Print Functions
        function removeFootnotes(text) {
            if (!text) return text;

            // Remove content within quotes that appears to be footnotes/annotations
            // Pattern matches quoted phrases that contain explanatory text like "lit.", "cf.", "trad.", etc.
            let cleaned = text.replace(/"[^"]*(?:lit\.|cf\.|trad\.|NJPS|uncertain|connected with|often in)[^"]*"/gi, '');

            // Clean up any double spaces left behind
            cleaned = cleaned.replace(/\s{2,}/g, ' ');

            // Clean up spaces before punctuation
            cleaned = cleaned.replace(/\s+([,.])/g, '$1');

            return cleaned.trim();
        }

        function generatePrintSummary() {
            const summary = [];

            // Get selected books
            const bookSelect = document.getElementById('book-select');
            const selectedBooks = Array.from(bookSelect.selectedOptions).map(opt => opt.text);
            if (selectedBooks.length > 0) {
                summary.push(`<strong>Books:</strong> ${selectedBooks.join(', ')}`);
            }

            // Get selected chapters
            const chapterInput = document.getElementById('chapter-input').value;
            if (chapterInput && chapterInput.trim() !== '' && chapterInput.trim().toLowerCase() !== 'all') {
                summary.push(`<strong>Chapters:</strong> ${chapterInput}`);
            }

            // Get selected verses
            const verseInput = document.getElementById('verse-input').value;
            if (verseInput && verseInput.trim() !== '' && verseInput.trim().toLowerCase() !== 'all') {
                summary.push(`<strong>Verses:</strong> ${verseInput}`);
            }

            // Get figurative types
            const selectedTypes = Array.from(appState.selectedTypes);
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };
            const typeNames = selectedTypes.map(t => typeLabels[t]);
            if (appState.showNotFigurative) {
                typeNames.push('Not Figurative');
            }
            if (typeNames.length > 0) {
                summary.push(`<strong>Figurative Types:</strong> ${typeNames.join(', ')}`);
            }

            // Get text version
            const textVersion = document.querySelector('input[name="text-version"]:checked').value;
            summary.push(`<strong>Text Version:</strong> ${textVersion === 'sacred' ? 'Sacred Names' : 'Traditional Jewish'}`);

            // Get search terms
            if (appState.currentSearch.text) {
                const searchType = appState.searchType === 'hebrew' ? 'Hebrew' : 'English';
                summary.push(`<strong>${searchType} Search:</strong> "${appState.currentSearch.text}"`);
            }

            // Get metadata search terms
            const metadataTerms = [];
            if (appState.currentSearch.target) {
                metadataTerms.push(`Target: "${appState.currentSearch.target}"`);
            }
            if (appState.currentSearch.vehicle) {
                metadataTerms.push(`Vehicle: "${appState.currentSearch.vehicle}"`);
            }
            if (appState.currentSearch.ground) {
                metadataTerms.push(`Ground: "${appState.currentSearch.ground}"`);
            }
            if (appState.currentSearch.posture) {
                metadataTerms.push(`Posture: "${appState.currentSearch.posture}"`);
            }
            if (metadataTerms.length > 0) {
                summary.push(`<strong>Metadata Search:</strong> ${metadataTerms.join('; ')}`);
            }

            // Get verse count
            const verseCount = appState.filteredVerses ? appState.filteredVerses.length : 0;
            summary.push(`<strong>Verses Displayed:</strong> ${verseCount}`);

            return summary;
        }

        function preparePrintContent() {
            const textVersion = document.querySelector('input[name="text-version"]:checked').value;
            const useNonSacred = textVersion === 'non-sacred';

            // Generate filter summary header
            const summaryItems = generatePrintSummary();
            const summaryHTML = `
                <h1>Tzafun: Biblical Figurative Language Analysis</h1>
                <p style="font-style: italic;">A concordance of Biblical figurative language</p>
                <h2>Applied Filters and Selections</h2>
                <div class="filter-summary">
                    ${summaryItems.map(item => `<p>${item}</p>`).join('')}
                </div>
            `;
            document.getElementById('print-header').innerHTML = summaryHTML;

            // Get all verse containers
            const verseContainers = document.querySelectorAll('.verse-container');

            // For each verse, add print-specific content
            appState.filteredVerses.forEach((verse, index) => {
                const verseElement = verseContainers[index];
                if (!verseElement) return;

                // Remove any existing print elements
                verseElement.querySelectorAll('.print-deliberation, .print-annotation, .verse-text-columns').forEach(el => el.remove());

                // Get the Hebrew and English text from the existing display
                const hebrewTextElement = verseElement.querySelector('.hebrew-text');
                const englishTextElement = verseElement.querySelector('.english-text');

                // Create a wrapper for the text columns at the top
                if (hebrewTextElement && englishTextElement) {
                    const textColumnsHTML = `
                        <div class="verse-text-columns">
                            <div class="hebrew-text">${hebrewTextElement.innerHTML}</div>
                            <div class="english-text">${englishTextElement.innerHTML}</div>
                        </div>
                    `;
                    verseElement.querySelector('.verse-content').insertAdjacentHTML('afterbegin', textColumnsHTML);
                }

                // Add annotation details for each figurative instance FIRST (on top)
                if (verse.annotations && verse.annotations.length > 0) {
                    verse.annotations.forEach(annotation => {
                        const annotationHTML = createPrintAnnotation(annotation, useNonSacred);
                        verseElement.querySelector('.verse-content').insertAdjacentHTML('beforeend', annotationHTML);
                    });
                }

                // Add deliberation section AFTER annotations (on bottom)
                const deliberationField = useNonSacred ?
                    (verse.figurative_detection_deliberation_non_sacred || verse.figurative_detection_deliberation) :
                    verse.figurative_detection_deliberation;

                if (deliberationField) {
                    const modelName = verse.model_used || 'Unknown Model';
                    const formattedDeliberation = formatDeliberationText(deliberationField);
                    const deliberationHTML = `
                        <div class="print-deliberation">
                            <h4>Figurative Detection Deliberation<span class="model-badge">${modelName}</span></h4>
                            <div class="deliberation-content">${formattedDeliberation}</div>
                        </div>
                    `;
                    verseElement.querySelector('.verse-content').insertAdjacentHTML('beforeend', deliberationHTML);
                }
            });
        }

        function createPrintAnnotation(annotation, useNonSacred) {
            const hebrewPhrase = useNonSacred ?
                (annotation.figurative_text_in_hebrew_non_sacred || annotation.figurative_text_in_hebrew) :
                annotation.figurative_text_in_hebrew;
            const englishPhrase = useNonSacred ?
                (annotation.figurative_text_non_sacred || annotation.figurative_text) :
                annotation.figurative_text;

            // Get all active types
            const activeTypes = annotation.types || [];
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };

            const typeIndicators = activeTypes.map(type =>
                `<span class="type-indicator ${type}">${typeLabels[type]}</span>`
            ).join(' ');

            // Build annotation details
            const details = [];

            if (annotation.target) {
                const targetValue = Array.isArray(annotation.target) ? annotation.target.join(' → ') : annotation.target;
                details.push(`<strong>Target:</strong> ${targetValue}`);
            }

            if (annotation.vehicle) {
                const vehicleValue = Array.isArray(annotation.vehicle) ? annotation.vehicle.join(' → ') : annotation.vehicle;
                details.push(`<strong>Vehicle:</strong> ${vehicleValue}`);
            }

            if (annotation.ground) {
                const groundValue = Array.isArray(annotation.ground) ? annotation.ground.join(' → ') : annotation.ground;
                details.push(`<strong>Ground:</strong> ${groundValue}`);
            }

            if (annotation.posture) {
                const postureValue = Array.isArray(annotation.posture) ? annotation.posture.join(' → ') : annotation.posture;
                details.push(`<strong>Posture:</strong> ${postureValue}`);
            }

            if (annotation.confidence !== undefined) {
                details.push(`<strong>Confidence:</strong> ${annotation.confidence}`);
            }

            if (annotation.speaker) {
                details.push(`<strong>Speaker:</strong> ${annotation.speaker}`);
            }

            if (annotation.purpose) {
                details.push(`<strong>Purpose:</strong> ${annotation.purpose}`);
            }

            if (annotation.explanation) {
                details.push(`<strong>Explanation:</strong> ${annotation.explanation}`);
            }

            // Add validation reasons for each type
            const validationReasons = [];
            activeTypes.forEach(type => {
                const reasonKey = `validation_reason_${type}`;
                if (annotation[reasonKey]) {
                    validationReasons.push(`<strong>${typeLabels[type]} Validation:</strong> ${annotation[reasonKey]}`);
                }
            });

            return `
                <div class="print-annotation">
                    <h5>Annotation Details</h5>
                    <div class="annotation-phrase">
                        <div class="annotation-phrase-hebrew">${hebrewPhrase || ''}</div>
                        <div class="annotation-phrase-english">${englishPhrase || ''}</div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Figurative Types:</strong> ${typeIndicators}
                    </div>
                    ${details.map(detail => `<p>${detail}</p>`).join('')}
                    ${validationReasons.length > 0 ? '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ccc;">' + validationReasons.map(reason => `<p>${reason}</p>`).join('') + '</div>' : ''}
                </div>
            `;
        }

        function printPage() {
            // Prepare the content for printing
            preparePrintContent();

            // Trigger the browser's print dialog
            window.print();

            // Clean up print-specific content after printing
            setTimeout(() => {
                document.querySelectorAll('.print-deliberation, .print-annotation').forEach(el => el.remove());
                document.getElementById('print-header').innerHTML = '';
            }, 1000);
        }

        // DOM Elements
        const elements = {
            versesContainer: document.getElementById('verses-container'),
            detailPanel: document.getElementById('detail-panel'),
            selectedVerse: document.getElementById('selected-verse'),
            deliberationText: document.getElementById('deliberation-text'),
            modelUsed: document.getElementById('model-used'),
            annotationDetails: document.getElementById('annotation-details'),
            statsBar: document.getElementById('stats-bar'),
            loadBtn: document.getElementById('load-verses'),
            closePanel: document.getElementById('close-panel')
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function () {
            initializeEventListeners();
            loadStatistics();
            loadDefaultVerses(); // Load verses immediately
        });

        function initializeEventListeners() {
            // Type filter checkboxes
            document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    if (this.value === 'not_figurative') {
                        appState.showNotFigurative = this.checked;
                    } else {
                        if (this.checked) {
                            appState.selectedTypes.add(this.value);
                        } else {
                            appState.selectedTypes.delete(this.value);
                        }
                    }
                    filterAndRenderVerses();
                });
            });

            // Text version radio buttons
            document.querySelectorAll('input[name="text-version"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    appState.textVersion = this.value;
                    renderVerses();
                    // Update deliberation text if a verse is currently shown
                    const currentVerse = appState.verses.find(v => v.reference === elements.selectedVerse.textContent);
                    if (currentVerse) {
                        updateDeliberationDisplay(currentVerse);
                    }
                });
            });

            // Create debounced search function ONCE
            const debouncedSearch = debounce(handleSearch, 300);

            // Search inputs
            document.getElementById('search-input').addEventListener('input', function () {
                updateClearButtonVisibility();
                debouncedSearch();
            });

            // Metadata search listeners - auto-uncheck "Not Figurative" when metadata search is active
            const metadataInputs = ['target-search', 'vehicle-search', 'ground-search', 'posture-search'];
            metadataInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', function () {
                    if (this.value.trim()) {
                        uncheckNotFigurativeForMetadataSearch();
                    }
                    debouncedSearch();
                });
            });

            // Panel controls
            elements.closePanel.addEventListener('click', closeDetailPanel);
            elements.loadBtn.addEventListener('click', loadVerses);

            // Select All / Clear All buttons for figurative language types
            document.getElementById('select-all-types').addEventListener('click', function () {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (!checkbox.checked) {
                        checkbox.checked = true;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = true;
                        } else {
                            appState.selectedTypes.add(checkbox.value);
                        }
                    }
                });
                filterAndRenderVerses();
            });

            document.getElementById('clear-all-types').addEventListener('click', function () {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (checkbox.checked) {
                        checkbox.checked = false;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = false;
                        } else {
                            appState.selectedTypes.delete(checkbox.value);
                        }
                    }
                });
                filterAndRenderVerses();
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function uncheckNotFigurativeForMetadataSearch() {
            // Auto-uncheck "Not Figurative" when metadata search is active to avoid complex queries
            const notFigCheckbox = document.querySelector('input[value="not_figurative"]');
            if (notFigCheckbox && notFigCheckbox.checked) {
                notFigCheckbox.checked = false;
                appState.showNotFigurative = false;
            }
        }

        function handleSearch() {
            appState.currentSearch = {
                text: document.getElementById('search-input').value,
                target: document.getElementById('target-search').value,
                vehicle: document.getElementById('vehicle-search').value,
                ground: document.getElementById('ground-search').value,
                posture: document.getElementById('posture-search').value
            };
            filterAndRenderVerses();
        }

        // Hebrew Keyboard Functions
        function toggleSearchType(type) {
            appState.searchType = type;
            const hebrewToggle = document.getElementById('hebrew-toggle');
            const englishToggle = document.getElementById('english-toggle');
            const searchInput = document.getElementById('search-input');
            const keyboardToggle = document.getElementById('keyboard-toggle');

            if (type === 'hebrew') {
                hebrewToggle.classList.add('active');
                englishToggle.classList.remove('active');
                searchInput.placeholder = 'Search Hebrew text...';
                searchInput.style.direction = 'rtl';
                searchInput.style.textAlign = 'right';
                keyboardToggle.style.display = 'block';
            } else {
                englishToggle.classList.add('active');
                hebrewToggle.classList.remove('active');
                searchInput.placeholder = 'Search English text...';
                searchInput.style.direction = 'ltr';
                searchInput.style.textAlign = 'left';
                keyboardToggle.style.display = 'none';
                document.getElementById('hebrew-keyboard').classList.remove('active');
            }

            // Clear search when switching types
            const hadSearch = searchInput.value !== '';
            searchInput.value = '';
            updateClearButtonVisibility();

            // Only trigger search if there was actually a search term to clear
            if (hadSearch) {
                handleSearch();
            }
        }

        function toggleHebrewKeyboard() {
            const keyboard = document.getElementById('hebrew-keyboard');
            keyboard.classList.toggle('active');
        }

        function insertHebrew(char) {
            const input = document.getElementById('search-input');
            const cursorPos = input.selectionStart;
            const value = input.value;
            input.value = value.substring(0, cursorPos) + char + value.substring(cursorPos);
            input.setSelectionRange(cursorPos + char.length, cursorPos + char.length);
            input.focus();
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearSearch() {
            document.getElementById('search-input').value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearTextSearch() {
            const input = document.getElementById('search-input');
            input.value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function deleteLastChar() {
            const input = document.getElementById('search-input');
            if (input.value.length > 0) {
                input.value = input.value.slice(0, -1);
                updateClearButtonVisibility();
                handleSearch();
            }
        }

        function updateClearButtonVisibility() {
            const input = document.getElementById('search-input');
            const clearBtn = document.getElementById('clear-search-btn');
            if (input.value.length > 0) {
                clearBtn.classList.add('active');
            } else {
                clearBtn.classList.remove('active');
            }
        }

        function clearMetadataSearch() {
            document.getElementById('target-search').value = '';
            document.getElementById('vehicle-search').value = '';
            document.getElementById('ground-search').value = '';
            document.getElementById('posture-search').value = '';
            handleSearch();
        }

        // API Functions
        async function makeAPICall(endpoint, params = {}) {
            try {
                // Build URL with query parameters - use relative URL directly with fetch
                const url = new URL(`${API_BASE}${endpoint}`, window.location.origin);
                Object.keys(params).forEach(key => {
                    if (params[key] !== '' && params[key] !== null && params[key] !== undefined) {
                        url.searchParams.append(key, params[key]);
                    }
                });

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                return null;
            }
        }

        // Database selection functions removed - now using fixed database

        async function loadStatistics() {
            try {
                const stats = await makeAPICall('/statistics');
                if (stats) {
                    console.log('Database statistics:', stats);
                    // Update book selection options
                    updateBookOptions(stats.books);
                }
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        function updateBookOptions(books) {
            const bookSelect = document.getElementById('book-select');

            // Only update if the book select is empty or has different books
            if (bookSelect.options.length === 0) {
                bookSelect.innerHTML = '';
                // Biblical order
                const biblicalOrder = ['Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy', 'Psalms', 'Proverbs', 'Isaiah', 'Jeremiah', 'Ezekiel', 'Hosea', 'Joel', 'Amos'];
                biblicalOrder.forEach(book => {
                    if (books.includes(book)) {
                        const option = document.createElement('option');
                        option.value = book.toLowerCase();
                        option.textContent = book;
                        option.selected = true; // Select all by default
                        bookSelect.appendChild(option);
                    }
                });
            }
        }

        async function loadDefaultVerses() {
            // Load all books in biblical order by default
            await loadVersesFromAPI({
                books: 'genesis,exodus,leviticus,numbers,deuteronomy,psalms',
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                limit: 25,
                offset: 0
            });
        }

        async function loadVersesFromAPI(params = {}) {
            // Increment request counter to track this specific request
            appState.requestCounter++;
            const thisRequestId = appState.requestCounter;

            appState.loading = true;
            showLoading();

            try {
                const data = await makeAPICall('/verses', params);

                // Only process results if this is still the most recent request
                // This prevents race conditions where an older request completes after a newer one
                if (thisRequestId === appState.requestCounter && data) {
                    appState.verses = data.verses;
                    // Convert API response to frontend format
                    appState.pagination = {
                        ...data.pagination,
                        hasMore: data.pagination.has_more, // Convert snake_case to camelCase
                        total_figurative_instances: data.pagination.total_figurative_instances || 0
                    };

                    // Check if count is an estimate (0 instances = mixed query estimate)
                    // This happens when show_all_verses or show_not_figurative is enabled
                    const show_all_verses = appState.selectedTypes.size === 7 && appState.showNotFigurative;
                    const show_not_figurative = appState.showNotFigurative;
                    const isEstimate = (data.pagination.total_figurative_instances === 0 && (show_all_verses || show_not_figurative));
                    appState.pagination.countIsEstimate = isEstimate;

                    appState.filteredVerses = appState.verses; // API already filters
                    renderVerses();
                    updateStats();

                    // Trigger lazy count loading if estimate
                    if (isEstimate) {
                        loadExactCount(params);
                    }
                } else if (thisRequestId !== appState.requestCounter) {
                    // This request was superseded by a newer one, ignore results
                    console.log(`Ignoring stale API response (request ${thisRequestId}, current ${appState.requestCounter})`);
                } else if (!data) {
                    showError('Failed to load verses. Please ensure the API server is running.');
                }
            } catch (error) {
                // Only show error if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    console.error('Failed to load verses:', error);
                    showError('Failed to load verses. Please check your connection and try again.');
                }
            } finally {
                // Only clear loading state if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    appState.loading = false;
                }
            }
        }

        async function loadExactCount(params) {
            // Increment count request counter
            appState.countRequestCounter++;
            const thisCountRequestId = appState.countRequestCounter;

            try {
                // Build params for count endpoint (exclude limit and offset)
                const countParams = { ...params };
                delete countParams.limit;
                delete countParams.offset;

                console.log('Loading exact count in background...');
                const data = await makeAPICall('/verses/count', countParams);

                // Only update if this is still the most recent count request
                if (thisCountRequestId === appState.countRequestCounter && data) {
                    appState.pagination.total = data.total;
                    appState.pagination.total_figurative_instances = data.total_figurative_instances;
                    appState.pagination.countIsEstimate = false;
                    updateStats(); // Refresh display with exact count
                    console.log(`Exact count loaded: ${data.total} verses, ${data.total_figurative_instances} instances`);
                }
            } catch (error) {
                console.error('Failed to load exact count:', error);
                // Silently fail - estimate is good enough
            }
        }

        function showLoading() {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                    <p style="font-size: 0.9rem; opacity: 0.7; margin-top: 0.5rem;">First load may take up to 1 minute</p>
                </div>
            `;
        }

        function showError(message) {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <p style="color: #e74c3c;">⚠️ ${message}</p>
                    <button onclick="loadDefaultVerses()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;">
                        Try Again
                    </button>
                </div>
            `;
        }

        function filterAndRenderVerses() {
            // Check if user has selected nothing (clear all scenario)
            if (appState.selectedTypes.size === 0 && !appState.showNotFigurative) {
                // Show NO verses when clear all is pressed (user's request)
                elements.versesContainer.innerHTML = '<div class="loading"><p>No figurative language types selected. Please select at least one type to see verses.</p></div>';
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        No verses displayed - no figurative language types selected
                    </div>
                    <div></div>
                `;
                return;
            }

            // Reset pagination offset when filter changes
            appState.pagination.offset = 0;

            // Since filtering is now done server-side, we just need to reload with current filters
            const params = buildAPIParams();
            loadVersesFromAPI(params);
        }

        function buildAPIParams() {
            const books = Array.from(document.getElementById('book-select').selectedOptions).map(opt => opt.value);
            const chapters = document.getElementById('chapter-input').value;
            const verses = document.getElementById('verse-input').value;

            return {
                books: books.join(','),
                chapters: chapters || 'all',
                verses: verses || 'all',
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                search_hebrew: appState.searchType === 'hebrew' ? appState.currentSearch.text : '',
                search_english: appState.searchType === 'english' ? appState.currentSearch.text : '',
                search_target: appState.currentSearch.target,
                search_vehicle: appState.currentSearch.vehicle,
                search_ground: appState.currentSearch.ground,
                search_posture: appState.currentSearch.posture,
                limit: appState.pagination.limit,
                offset: appState.pagination.offset
            };
        }

        /*
 * ROBUST TEXT HIGHLIGHTING ENGINE
 * Handles HTML tags, Hebrew normalization, and complex overlapping highlights (figurative + search).
 */
        class TextHighlighter {
            constructor() { }

            static normalizeHebrew(text) {
                if (!text) return '';
                return text.normalize('NFD')
                    .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove vowels/cantillation
                    .replace(/־/g, ' ') // Maqaf to space
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            // Maps indices from a source string to a "cleaned" string (e.g., HTML -> Plain)
            // returns { text: string, map: [] } where map[cleanIndex] = sourceIndex
            static buildMap(sourceText) {
                let cleanText = '';
                const map = [];

                let i = 0;
                while (i < sourceText.length) {
                    const char = sourceText[i];

                    // Check for HTML tag
                    if (char === '<') {
                        const tagMatch = sourceText.substring(i).match(/^<[^>]+>/);
                        if (tagMatch) {
                            i += tagMatch[0].length;
                            continue;
                        }
                    }

                    // Check for common HTML entities
                    if (char === '&') {
                        const entityMatch = sourceText.substring(i).match(/^&([a-zA-Z0-9#]+);/);
                        if (entityMatch) {
                            const entity = entityMatch[1];
                            let decoded = ' ';
                            if (entity === 'nbsp') decoded = ' ';
                            else if (entity === 'amp') decoded = '&';
                            else if (entity === 'lt') decoded = '<';
                            else if (entity === 'gt') decoded = '>';
                            else if (entity === 'quot') decoded = '"';
                            else if (entity === 'apos') decoded = "'";

                            // Map the start of the entity to this decoded char
                            map.push(i);
                            cleanText += decoded;
                            i += entityMatch[0].length;
                            continue;
                        }
                    }

                    // Regular char
                    map.push(i);
                    cleanText += char;
                    i++;
                }

                return { text: cleanText, map };
            }

            // Step 2: Normalize the Plain Text (Plain -> Normalized)
            static buildNormalizationMap(plainText, language) {
                let normalizedText = '';
                const map = []; // map[normIndex] = plainIndex

                for (let i = 0; i < plainText.length; i++) {
                    const char = plainText[i];

                    if (language === 'hebrew') {
                        // Hebrew Logic
                        if (/[\u0591-\u05C7\u05F0-\u05F4]/.test(char)) {
                            // Skip diacritic
                            continue;
                        }
                        if (char === '־') {
                            map.push(i);
                            normalizedText += ' ';
                            continue;
                        }
                        map.push(i);
                        normalizedText += char;
                    } else {
                        // English Logic - STRICTER normalization
                        // Skip ALL punctuation, brackets, parens, quotes (smart and straight)
                        // Keep only letters, numbers, and spaces
                        if (/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/.test(char)) {
                            // If it's a hyphen, replacing with space arguably makes more sense for "anti-aircraft" -> "anti aircraft"
                            // But for now let's just skip it to match previous "strip" logic, or mimic hebrew maqaf behavior?
                            // Actually, let's just skip it.
                            continue;
                        }
                        map.push(i);
                        normalizedText += char.toLowerCase();
                    }
                }

                return { text: normalizedText, map };
            }

            // Helper to strip parenthetical/bracketed glosses from figurative text (e.g. "foo (lit. bar)")
            static cleanFigurativeText(text, language) {
                if (!text) return '';
                if (language === 'hebrew') return text;

                // Remove parenthetical explanations like "(lit. ...)"
                let coreText = text.replace(/\s*\([^)]*\)/g, '');
                // Remove bracketed explanations
                coreText = coreText.replace(/\s*\[[^\]]*\]/g, '');
                // Clean up whitespace
                return coreText.replace(/\s+/g, ' ').trim();
            }

            // Main Entry: Find Ranges
            // Returns [{start, end, type, data}] (indices in original HTML)
            static findRanges(html, annotations, searchTerm, language) {
                const results = [];

                // 1. HTML -> Plain
                const plainObj = this.buildMap(html);

                // 2. Plain -> Normalized
                const normObj = this.buildNormalizationMap(plainObj.text, language);

                // 3. Search for Annotations
                annotations.forEach(ann => {
                    const phrase = language === 'hebrew' ? ann.figurative_text_in_hebrew : ann.figurative_text;
                    if (!phrase) return;

                    // Clean the figurative phrase first (remove "lit." etc)
                    const cleanPhrase = this.cleanFigurativeText(phrase, language);

                    // Normalize the target phrase using same logic
                    let normPhrase = '';
                    if (language === 'hebrew') {
                        normPhrase = cleanPhrase.normalize('NFD')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '')
                            .replace(/־/g, ' ');
                    } else {
                        // For English, we also need to handle ellipses "..." or "…"
                        // Splitting by ellipses allows matching discontinuous phrases
                        // But for now, let's just try to match the core text
                        // normalize using same strict regex
                        normPhrase = cleanPhrase.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '');
                    }

                    if (!normPhrase) return;

                    // Search Loop
                    let pos = 0;

                    // Logic for English ellipses handling
                    if (language !== 'hebrew' && (cleanPhrase.includes('...') || cleanPhrase.includes('…'))) {
                        // Split into parts
                        const parts = cleanPhrase.split(/…|\.\.\./).map(p =>
                            p.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '').trim()
                        ).filter(p => p.length > 0);

                        if (parts.length > 0) {
                            // Find all occurrences of the FIRST part
                            let searchPos = 0;
                            while (true) {
                                const startIdx = normObj.text.indexOf(parts[0], searchPos);
                                if (startIdx === -1) break;

                                // Verify subsequent parts follow in order
                                let currentIdx = startIdx + parts[0].length;
                                let allFound = true;
                                let matchEnd = currentIdx;

                                for (let i = 1; i < parts.length; i++) {
                                    const nextIdx = normObj.text.indexOf(parts[i], currentIdx);
                                    if (nextIdx === -1) {
                                        allFound = false;
                                        break;
                                    }
                                    currentIdx = nextIdx + parts[i].length;
                                    matchEnd = currentIdx;
                                }

                                if (allFound) {
                                    results.push({
                                        startNorm: startIdx,
                                        endNorm: matchEnd,
                                        type: 'figurative',
                                        priority: 1,
                                        data: ann
                                    });
                                }
                                searchPos = startIdx + 1;
                            }
                            return; // Skip standard matching for this annotation
                        }
                    }

                    // Standard exact match
                    while (true) {
                        const idx = normObj.text.indexOf(normPhrase, pos);
                        if (idx === -1) break;

                        results.push({
                            startNorm: idx,
                            endNorm: idx + normPhrase.length,
                            type: 'figurative',
                            priority: 1,
                            data: ann
                        });

                        pos = idx + 1;
                    }
                });

                // 4. Search for SearchTerm
                if (searchTerm) {
                    let normSearch = '';
                    if (language === 'hebrew') {
                        normSearch = searchTerm.normalize('NFD')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '')
                            .replace(/־/g, ' ');
                    } else {
                        // For English search, be a bit more flexible with partial matches? 
                        // Current logic matches 'man' in 'human'.
                        normSearch = searchTerm.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '');
                    }

                    if (normSearch) {
                        let pos = 0;
                        while (true) {
                            const idx = normObj.text.indexOf(normSearch, pos);
                            if (idx === -1) break;

                            results.push({
                                startNorm: idx,
                                endNorm: idx + normSearch.length,
                                type: 'search',
                                priority: 2,
                                data: searchTerm
                            });
                            pos = idx + 1;
                        }
                    }
                }

                // 5. Convert Norm Indices to HTML Indices
                const validRanges = [];
                results.forEach(r => {
                    // map norm -> plain
                    if (r.startNorm >= normObj.map.length) return;

                    const pStart = normObj.map[r.startNorm];

                    let pEnd;
                    if (r.endNorm < normObj.map.length) {
                        pEnd = normObj.map[r.endNorm];
                    } else {
                        pEnd = plainObj.text.length;
                    }

                    // map plain -> html
                    if (pStart >= plainObj.map.length) return;
                    const hStart = plainObj.map[pStart];

                    let hEnd;
                    if (pEnd < plainObj.map.length) {
                        hEnd = plainObj.map[pEnd];
                    } else {
                        // Safe fallback for end of string
                        hEnd = html.length;
                    }

                    validRanges.push({
                        start: hStart,
                        end: hEnd,
                        type: r.type,
                        priority: r.priority,
                        data: r.data
                    });
                });

                return validRanges;
            }

            // Step 6. Apply Highlights
            static applyHighlights(html, ranges) {
                if (ranges.length === 0) return html;

                // Flatten to points: { index, type: 'start'|'end', priority, ... }
                const points = [];
                ranges.forEach((r, i) => {
                    points.push({ idx: r.start, type: 'start', priority: r.priority, id: i, data: r.data, rangeType: r.type });
                    points.push({ idx: r.end, type: 'end', priority: r.priority, id: i, data: r.data, rangeType: r.type });
                });

                points.sort((a, b) => {
                    if (a.idx !== b.idx) return a.idx - b.idx;
                    // Order at same index: Ends before Starts (Visual containment)
                    return a.type === 'end' ? -1 : 1;
                });

                let result = '';
                let lastIdx = 0;

                let activeFigurative = null;
                let activeSearch = false;

                for (let i = 0; i < points.length; i++) {
                    const point = points[i];

                    // Add text up to this point
                    if (point.idx > lastIdx) {
                        const chunk = html.substring(lastIdx, point.idx);

                        let wrapped = chunk;

                        if (activeSearch) {
                            wrapped = `<span class="search-highlight">${wrapped}</span>`;
                        }
                        if (activeFigurative) {
                            wrapped = createFigurativeTag(wrapped, activeFigurative);
                        }

                        result += wrapped;
                    }

                    // Update state
                    if (point.type === 'start') {
                        if (point.rangeType === 'figurative') activeFigurative = point.data;
                        if (point.rangeType === 'search') activeSearch = true;
                    } else {
                        // End point
                        if (point.rangeType === 'figurative') activeFigurative = null;
                        if (point.rangeType === 'search') activeSearch = false;
                    }

                    lastIdx = point.idx;
                }

                // Trailing text
                if (lastIdx < html.length) {
                    result += html.substring(lastIdx);
                }

                return result;
            }
        }

        function createFigurativeTag(content, annotation) {
            const visibleTypes = annotation.types || [];
            if (visibleTypes.length === 0) return content;

            const typeIndicators = visibleTypes.map(type => {
                const typeDisplayName = type.charAt(0).toUpperCase() + type.slice(1);
                return `<span class="type-indicator"><span class="type-color-square ${type}"></span>${typeDisplayName}</span>`;
            }).join('');

            const tooltip = `<div class="type-tooltip">${typeIndicators}</div>`;

            // Minimal Annotation for data attribute
            const minimalAnnotation = {
                verse_id: annotation.verse_id,
                verse_reference: annotation.verse_reference,
                figurative_text: annotation.figurative_text,
                types: annotation.types,
                target: annotation.target,
                vehicle: annotation.vehicle,
                ground: annotation.ground,
                posture: annotation.posture,
                speaker: annotation.speaker,
                confidence: annotation.confidence
            };

            const escapedJson = JSON.stringify(minimalAnnotation)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;');

            return `<span class="figurative-highlight" data-annotation='${escapedJson}'>${content}${tooltip}</span>`;
        }

        // Clean Hebrew Helper (kept for compatibility if referenced elsewhere, but normalized)
        function cleanHebrewText(text) {
            // Just basic HTML cleanup for display if needed
            if (!text) return '';
            return text.replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ').trim();
        }

        function renderVerses() {
            if (appState.filteredVerses.length === 0) {
                elements.versesContainer.innerHTML = '<div class="loading"><p>No verses match your current filters.</p></div>';
                return;
            }

            const versesHTML = appState.filteredVerses.map(verse => {
                // 1. Get Base HTML
                let hebrewHtml = appState.textVersion === 'sacred' ? verse.hebrew_text : verse.hebrew_text_non_sacred;
                if (!hebrewHtml) hebrewHtml = '[Hebrew text unavailable]';

                let englishHtml = appState.textVersion === 'sacred' ? verse.english_text_clean : verse.english_text_clean_non_sacred;
                englishHtml = removeFootnotes(englishHtml);

                // 2. Prepare Annotations
                const annotations = verse.annotations.map(annotation => ({
                    ...annotation,
                    verse_reference: verse.reference,
                    verse_id: verse.id,
                    verse_deliberation: verse.figurative_detection_deliberation,
                    verse_model_used: verse.model_used
                }));

                // 3. Highlight Hebrew
                const hebrewRanges = TextHighlighter.findRanges(hebrewHtml, annotations, appState.searchType === 'hebrew' ? appState.currentSearch.text : null, 'hebrew');
                const processedHebrew = TextHighlighter.applyHighlights(hebrewHtml, hebrewRanges);

                // 4. Highlight English
                const englishRanges = TextHighlighter.findRanges(englishHtml, annotations, appState.searchType === 'english' ? appState.currentSearch.text : null, 'english');
                const processedEnglish = TextHighlighter.applyHighlights(englishHtml, englishRanges);

                return `
                    <div class="verse-container">
                        <div class="verse-header" onclick="showVerseDetails('${verse.reference}', ${verse.id})">
                            ${verse.reference}
                        </div>
                        <div class="verse-content">
                            <div class="english-text">${processedEnglish}</div>
                            <div class="hebrew-text">${processedHebrew}</div>
                        </div>
                    </div>
                `;
            }).join('');

            elements.versesContainer.innerHTML = versesHTML;

            // Add click listeners
            document.querySelectorAll('.figurative-highlight').forEach(element => {
                element.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const annotation = JSON.parse(this.dataset.annotation);
                    showAnnotationDetails(annotation);
                });
            });
        }

        function updateDeliberationDisplay(verse) {
            if (!verse) return;

            const deliberation = appState.textVersion === 'sacred'
                ? verse.figurative_detection_deliberation
                : verse.figurative_detection_deliberation_non_sacred;

            elements.deliberationText.innerHTML = formatDeliberationText(deliberation);
        }

        function formatDeliberationText(text) {
            if (!text) return '';

            // Convert markdown-style formatting to HTML
            let formatted = text;

            // Replace **bold** with spans
            formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<span class="deliberation-bold">$1</span>');

            // Replace *italic* with spans (but not part of **)
            formatted = formatted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span class="deliberation-italic">$1</span>');

            // Replace common labels with styled versions - and add paragraph breaks before them
            formatted = formatted.replace(/\s*<span class="deliberation-label">Phrase\/Concept:<\/span>/g, '<br><br><span class="deliberation-label">Phrase/Concept:</span>');
            formatted = formatted.replace(/\s*<span class="deliberation-label">Considered:<\/span>/g, '<br><br><span class="deliberation-label">Considered:</span>');
            formatted = formatted.replace(/\s*<span class="deliberation-label">Reasoning for (including|excluding):<\/span>/g, '<br><br><span class="deliberation-label">Reasoning for $1:</span>');

            // Also handle the original pattern replacement
            formatted = formatted.replace(/\*\*Phrase\/Concept:\*\*/g, '<br><br><span class="deliberation-label">Phrase/Concept:</span>');
            formatted = formatted.replace(/\*\*Considered:\*\*/g, '<br><br><span class="deliberation-label">Considered:</span>');
            formatted = formatted.replace(/\*\*Reasoning for (including|excluding):\*\*/g, '<br><br><span class="deliberation-label">Reasoning for $1:</span>');

            // Split into numbered items
            const lines = formatted.split(/(?=\d+\.\s+(?:\*\*|<span))/);

            if (lines.length > 1) {
                // Has numbered items - format them
                return lines.map(line => {
                    const match = line.match(/^(\d+)\.\s+(.+)$/s);
                    if (match) {
                        const [, num, content] = match;
                        // Remove leading <br> tags from the start of content
                        const cleanContent = content.trim().replace(/^(?:<br>)+/, '');
                        return `<div class="deliberation-item"><span class="deliberation-number">${num}.</span> ${cleanContent}</div>`;
                    }
                    return line.trim() ? `<div>${line.trim()}</div>` : '';
                }).filter(Boolean).join('');
            }

            return formatted;
        }

        function showVerseDetails(reference, verseId) {
            const verse = appState.verses.find(v => v.id === verseId);
            if (!verse) return;

            elements.selectedVerse.textContent = reference;
            updateDeliberationDisplay(verse);
            elements.modelUsed.textContent = verse.model_used;

            // Clear any previous annotation details when showing verse details
            elements.annotationDetails.innerHTML = '';

            // Remove annotation-details class and use regular panel
            elements.detailPanel.classList.remove('annotation-details');
            elements.detailPanel.classList.add('active');

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open-large');
            mainContent.classList.add('panel-open');
        }

        function showAnnotationDetails(minimalAnnotation) {
            // Find the full annotation data from appState.verses
            const verse = appState.verses.find(v => v.id === minimalAnnotation.verse_id);
            let fullAnnotation = minimalAnnotation;

            if (verse) {
                // Find the full annotation that matches this minimal one
                fullAnnotation = verse.annotations.find(ann =>
                    ann.figurative_text === minimalAnnotation.figurative_text &&
                    JSON.stringify(ann.types) === JSON.stringify(minimalAnnotation.types)
                ) || minimalAnnotation;

                // Update verse deliberation
                elements.selectedVerse.textContent = verse.reference;
                updateDeliberationDisplay(verse);
                elements.modelUsed.textContent = verse.model_used || 'Unknown';
            }

            // Format validation reasons using fullAnnotation
            const validationReasons = [];
            if (fullAnnotation.validation_reason_metaphor) validationReasons.push(`Metaphor: ${fullAnnotation.validation_reason_metaphor}`);
            if (fullAnnotation.validation_reason_simile) validationReasons.push(`Simile: ${fullAnnotation.validation_reason_simile}`);
            if (fullAnnotation.validation_reason_personification) validationReasons.push(`Personification: ${fullAnnotation.validation_reason_personification}`);
            if (fullAnnotation.validation_reason_idiom) validationReasons.push(`Idiom: ${fullAnnotation.validation_reason_idiom}`);
            if (fullAnnotation.validation_reason_hyperbole) validationReasons.push(`Hyperbole: ${fullAnnotation.validation_reason_hyperbole}`);
            if (fullAnnotation.validation_reason_metonymy) validationReasons.push(`Metonymy: ${fullAnnotation.validation_reason_metonymy}`);
            if (fullAnnotation.validation_reason_other) validationReasons.push(`Other: ${fullAnnotation.validation_reason_other}`);

            const validationHTML = validationReasons.length > 0 ?
                `<div style="margin-bottom: 1rem;">
                    <strong>Validation Reasons:</strong>
                    <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        ${validationReasons.map(reason => `<li>${reason}</li>`).join('')}
                    </ul>
                </div>` : '';

            // Get Hebrew and English phrases (respect non-sacred setting)
            const useNonSacred = appState.textVersion === 'non-sacred';
            const hebrewPhrase = useNonSacred ?
                (fullAnnotation.figurative_text_in_hebrew_non_sacred || fullAnnotation.figurative_text_in_hebrew) :
                fullAnnotation.figurative_text_in_hebrew;
            const englishPhrase = useNonSacred ?
                (fullAnnotation.figurative_text_non_sacred || fullAnnotation.figurative_text) :
                fullAnnotation.figurative_text;

            // Create type badges
            const typeLabels = {
                'metaphor': 'Metaphor',
                'simile': 'Simile',
                'personification': 'Personification',
                'idiom': 'Idiom',
                'hyperbole': 'Hyperbole',
                'metonymy': 'Metonymy',
                'other': 'Other'
            };
            const typeBadges = fullAnnotation.types.map(type =>
                `<span class="type-indicator ${type}">${typeLabels[type]}</span>`
            ).join('');

            const detailsHTML = `
                <h4 style="color: var(--accent-color); margin-bottom: 1rem;">Annotation Details</h4>

                <div class="annotation-phrase">
                    <div class="annotation-phrase-hebrew">${hebrewPhrase || ''}</div>
                    <div class="annotation-phrase-english">${englishPhrase || ''}</div>
                </div>

                <div class="type-badges">
                    ${typeBadges}
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <strong>Target:</strong><br>
                        <small>${Array.isArray(fullAnnotation.target) ? fullAnnotation.target.join(' → ') : (fullAnnotation.target || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Vehicle:</strong><br>
                        <small>${Array.isArray(fullAnnotation.vehicle) ? fullAnnotation.vehicle.join(' → ') : (fullAnnotation.vehicle || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Ground:</strong><br>
                        <small>${Array.isArray(fullAnnotation.ground) ? fullAnnotation.ground.join(' → ') : (fullAnnotation.ground || 'N/A')}</small>
                    </div>
                    <div>
                        <strong>Posture:</strong><br>
                        <small>${Array.isArray(fullAnnotation.posture) ? fullAnnotation.posture.join(' → ') : (fullAnnotation.posture || 'N/A')}</small>
                    </div>
                </div>

                <div style="margin-bottom: 1rem;">
                    <strong>Explanation:</strong><br>
                    <p style="margin-top: 0.5rem;">${fullAnnotation.explanation || 'No explanation available'}</p>
                </div>

                ${validationHTML}

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div><strong>Speaker:</strong> ${fullAnnotation.speaker || 'N/A'}</div>
                    <div><strong>Confidence:</strong> ${fullAnnotation.confidence ? (fullAnnotation.confidence * 100).toFixed(1) + '%' : 'N/A'}</div>
                </div>
            `;

            elements.annotationDetails.innerHTML = detailsHTML;
            elements.detailPanel.classList.add('active', 'annotation-details');

            // Remove previous panel classes and add large panel class
            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open');
            mainContent.classList.add('panel-open-large');
        }

        function closeDetailPanel() {
            elements.detailPanel.classList.remove('active', 'annotation-details');
            elements.annotationDetails.innerHTML = '';

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open', 'panel-open-large');
        }

        async function updateStats() {
            const currentVerses = appState.verses.length;
            const totalAnnotations = appState.verses.reduce((sum, verse) => sum + verse.annotations.length, 0);
            const totalCount = appState.pagination.total;
            const totalFigurativeInstances = appState.pagination.total_figurative_instances || 0;

            // Calculate how many verses remain to be loaded
            const remainingVerses = totalCount - currentVerses;

            // Estimate next batch size based on remaining verses
            let estimatedNextBatch = Math.min(appState.pagination.limit, remainingVerses);

            const nextButton = appState.pagination.hasMore ?
                `<button class="nav-button" onclick="loadMore()">Load Next ${estimatedNextBatch} Verses</button>` :
                '<span style="color: #28a745; font-weight: 600;">✓ All verses loaded</span>';

            // Check if we're showing an estimate
            if (appState.pagination.countIsEstimate) {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances)
                        <span style="color: #6c757d; font-style: italic;">(calculating total...)</span>
                    </div>
                    <div>${nextButton}</div>
                `;
            } else {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances) of ${totalCount.toLocaleString()} verses (${totalFigurativeInstances.toLocaleString()} figurative language instances)
                    </div>
                    <div>${nextButton}</div>
                `;
            }
        }

        async function loadMore() {
            if (appState.pagination.hasMore && !appState.loading) {
                // Increment request counter to track this specific request
                appState.requestCounter++;
                const thisRequestId = appState.requestCounter;

                const params = buildAPIParams();
                params.offset = appState.pagination.offset + appState.pagination.limit;

                appState.loading = true;
                try {
                    const data = await makeAPICall('/verses', params);

                    // Only process results if this is still the most recent request
                    if (thisRequestId === appState.requestCounter && data) {
                        appState.verses = [...appState.verses, ...data.verses];
                        // Preserve total and total_figurative_instances from initial load (may have been updated by background count)
                        const preservedTotal = appState.pagination.total;
                        const preservedFigurativeInstances = appState.pagination.total_figurative_instances;
                        // Convert API response to frontend format
                        appState.pagination = {
                            ...data.pagination,
                            hasMore: data.pagination.has_more, // Convert snake_case to camelCase
                            total: preservedTotal || data.pagination.total,
                            total_figurative_instances: preservedFigurativeInstances || data.pagination.total_figurative_instances
                        };
                        appState.filteredVerses = appState.verses;
                        renderVerses();
                        updateStats();
                    } else if (thisRequestId !== appState.requestCounter) {
                        console.log(`Ignoring stale loadMore response (request ${thisRequestId}, current ${appState.requestCounter})`);
                    }
                } catch (error) {
                    if (thisRequestId === appState.requestCounter) {
                        console.error('Failed to load more verses:', error);
                    }
                } finally {
                    if (thisRequestId === appState.requestCounter) {
                        appState.loading = false;
                    }
                }
            }
        }

        async function loadVerses() {
            // Reset pagination and load fresh data
            appState.pagination.offset = 0;
            const params = buildAPIParams();
            await loadVersesFromAPI(params);
        }
    </script>
</body>

</html>