<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tzafun</title>
    <style>
        /* Hebrew Font Support */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;600&family=Crimson+Text:wght@400;600&display=swap');

        :root {
            /* Figurative Language Colors - Elegant but distinct palette */
            --metaphor-color: #a0695f;
            --simile-color: #5a8ca8;
            --personification-color: #9370a8;
            --idiom-color: #c9a255;
            --hyperbole-color: #c17a61;
            --metonymy-color: #5d9b82;
            --other-color: #7a8896;

            /* Layout Colors */
            --sidebar-bg: #f8f9fa;
            --main-bg: #ffffff;
            --border-color: #dee2e6;
            --text-color: #212529;
            --accent-color: #007bff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--main-bg);
        }

        /* Main Layout Grid */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
            max-height: 100vh;
            position: relative;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #0a1930 0%, #020408 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            flex: 1;
        }

        .header h1 {
            font-size: 2.07rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.3rem;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .header-hebrew-quote {
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 1.048rem !important;
            opacity: 0.9;
            direction: ltr;
            text-align: left;
            line-height: 1;
        }

        .header-attribution {
            font-size: 1.3rem;
            color: white;
            opacity: 0.9;
            text-align: right;
            line-height: 1.4;
            max-width: 350px;
        }

        .header-attribution a {
            color: white;
            text-decoration: none;
            cursor: pointer;
        }

        .header-attribution a:hover {
            text-decoration: underline;
        }

        .header h1 {
            cursor: pointer;
        }

        .header h1:hover {
            opacity: 0.8;
        }

        /* About Page Styles */
        .about-page {
            display: none;
            overflow-y: auto;
            height: calc(100vh - 120px);
            grid-column: 1 / -1;
        }

        .about-page.active {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
        }

        .about-toc {
            padding: 2rem 1.5rem;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            position: sticky;
            top: 0;
            height: fit-content;
        }

        .about-toc h3 {
            font-size: 1rem;
            color: #2b394f;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #2b394f;
        }

        .about-toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .about-toc li {
            margin-bottom: 0.75rem;
        }

        .about-toc a {
            color: #495057;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s;
        }

        .about-toc a:hover {
            color: #2b394f;
            text-decoration: underline;
        }

        .about-content {
            padding: 2rem;
            max-width: 900px;
        }

        .about-page h2 {
            font-size: 1.8rem;
            color: #2b394f;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #2b394f;
            padding-bottom: 0.5rem;
        }

        .about-page h2:first-child {
            margin-top: 0;
        }

        .about-page p {
            margin-bottom: 1rem;
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .about-page strong {
            font-weight: 600;
            color: #2b394f;
            font-size: 1.3em;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 20px;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Sidebar */
        .sidebar {
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        .sidebar section {
            margin-bottom: 2rem;
        }

        .sidebar h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2b394f;
            border-bottom: 2px solid #2b394f;
            padding-bottom: 0.3rem;
        }

        .sidebar h3.tooltip {
            display: block;
        }

        .sidebar label {
            display: block;
            margin-bottom: 0.5rem;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .sidebar input, .sidebar select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .sidebar input[type="checkbox"], .sidebar input[type="radio"] {
            width: auto;
            margin-right: 0.5rem;
            margin-bottom: 0;
        }

        /* Type Filter Colors */
        .type-filters label {
            position: relative;
            padding-left: 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .type-filters input[type="checkbox"] {
            position: relative;
            z-index: 2;
            margin-right: 0;
        }

        .type-filters input[type="checkbox"]:checked + .filter-color {
            opacity: 1;
        }

        .filter-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            opacity: 0.4;
            border: 1px solid rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .filter-color.metaphor { background-color: var(--metaphor-color); }
        .filter-color.simile { background-color: var(--simile-color); }
        .filter-color.personification { background-color: var(--personification-color); }
        .filter-color.idiom { background-color: var(--idiom-color); }
        .filter-color.hyperbole { background-color: var(--hyperbole-color); }
        .filter-color.metonymy { background-color: var(--metonymy-color); }
        .filter-color.other { background-color: var(--other-color); }

        /* Main Content Area */
        .main-content {
            padding: 1.5rem;
            padding-bottom: 120px; /* Space for fixed stats bar */
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        /* Verse Container */
        .verse-container {
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: box-shadow 0.2s ease;
        }

        .verse-container:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .verse-header {
            background-color: #f8f9fa;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
        }

        .verse-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 1.5rem;
            position: relative;
        }

        /* Text Columns */
        .english-text {
            font-size: 1.1rem;
            line-height: 1.8;
            position: relative;
            padding-bottom: 1rem;
        }

        .hebrew-text {
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 1.3rem;
            line-height: 1.8;
            direction: rtl;
            text-align: right;
            position: relative;
            padding-bottom: 1rem;
        }

        /* Old annotation CSS removed - using simple highlighting approach */

        /* Simple Figurative Text Highlighting */
        .figurative-highlight {
            background-color: #fff3cd; /* Light yellow highlighting */
            padding: 1px 2px;
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .figurative-highlight:hover {
            background-color: #ffeaa7; /* Slightly more yellow on hover */
        }

        /* Tooltip for showing figurative types */
        .type-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            margin-bottom: 5px;
        }

        .type-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .figurative-highlight:hover .type-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Type indicator squares in tooltip */
        .type-indicator {
            display: inline-flex;
            align-items: center;
            margin-right: 8px;
        }

        .type-indicator:last-child {
            margin-right: 0;
        }

        .type-color-square {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
            display: inline-block;
        }

        .type-color-square.metaphor {
            background-color: var(--metaphor-color);
        }

        .type-color-square.simile {
            background-color: var(--simile-color);
        }

        .type-color-square.personification {
            background-color: var(--personification-color);
        }

        .type-color-square.idiom {
            background-color: var(--idiom-color);
        }

        .type-color-square.hyperbole {
            background-color: var(--hyperbole-color);
        }

        .type-color-square.metonymy {
            background-color: var(--metonymy-color);
        }

        .type-color-square.other {
            background-color: var(--other-color);
        }

        /* Old annotation line CSS removed */

        /* Bottom Detail Panel */
        .detail-panel {
            position: fixed;
            bottom: 0;
            left: 300px;
            right: 0;
            background-color: white;
            border-top: 1px solid var(--border-color);
            padding: 1.5rem;
            max-height: 40vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .detail-panel.active {
            transform: translateY(0);
        }

        /* Larger panel for annotation details */
        .detail-panel.annotation-details {
            max-height: 60vh;
        }

        /* Adjust main content when panel is open */
        .main-content.panel-open {
            padding-bottom: 40vh;
        }

        .main-content.panel-open-large {
            padding-bottom: 60vh;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header h3 {
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0.25rem;
        }

        .close-btn:hover {
            color: var(--text-color);
        }

        .deliberation-section {
            margin-bottom: 1.5rem;
        }

        .deliberation-section h4 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }

        .model-badge {
            display: inline-block;
            background-color: #e9ecef;
            color: #495057;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
        }

        .spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .sidebar {
                max-height: none;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .verse-content {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .hebrew-text {
                order: -1;
            }

            .detail-panel {
                left: 0;
                max-height: 50vh;
            }

            .main-content.panel-open {
                padding-bottom: 50vh;
            }
        }

        /* Search Highlighting - pink for search matches */
        .search-highlight {
            background-color: #ffb3d9;
            font-weight: 600;
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* When search highlight is inside figurative highlight, pink takes priority */
        .figurative-highlight .search-highlight {
            background-color: #ffb3d9;
            box-shadow: 0 0 0 2px #fff3cd; /* Yellow border to show it's also figurative */
        }

        /* Stats Bar */
        .stats-bar {
            background-color: #f8f9fa;
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.95rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 100;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
        }

        .stats-text {
            flex: 1;
        }

        .nav-button {
            background: linear-gradient(135deg, #0a1930 0%, #2b394f 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .nav-button:hover {
            background: linear-gradient(135deg, #2b394f 0%, #0a1930 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        /* Hebrew Keyboard Styles */
        .search-type-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #2b394f;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            color: #2b394f;
        }

        .toggle-btn:hover {
            background-color: #f8f9fa;
        }

        .toggle-btn.active {
            background-color: #2b394f;
            color: white;
            border-color: #2b394f;
        }

        .hebrew-keyboard {
            display: none;
            grid-template-columns: repeat(9, 1fr);
            gap: 0.15rem;
            margin: 0.5rem 0;
            padding: 0.4rem;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .hebrew-keyboard.active {
            display: grid;
        }

        .hebrew-key {
            padding: 0.3rem 0.2rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            text-align: center;
            font-family: 'Noto Sans Hebrew', serif;
            font-size: 0.9rem;
            transition: background-color 0.1s ease;
            min-height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hebrew-key:hover {
            background-color: #e9ecef;
        }

        .hebrew-key.wide {
            grid-column: span 2;
        }

        .hebrew-key.action {
            font-size: 0.75rem;
            font-family: 'Crimson Text', serif;
        }

        .search-input-container {
            position: relative;
            margin-bottom: 0.5rem;
        }

        .keyboard-toggle {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #2b394f;
            cursor: pointer;
            font-size: 1rem;
            color: #2b394f;
            border-radius: 3px;
            padding: 2px 6px;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .keyboard-toggle:hover {
            background-color: #f8f9fa;
        }

        /* Ensure keyboard doesn't overlap with search input */
        #search-input {
            margin-bottom: 0;
            padding-right: 4rem; /* Make room for both keyboard and clear buttons */
        }

        .clear-search-btn {
            position: absolute;
            right: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #6c757d;
            cursor: pointer;
            font-size: 1rem;
            color: #6c757d;
            border-radius: 3px;
            padding: 3px 6px;
            transition: all 0.2s ease;
            z-index: 1;
            display: none;
        }

        .clear-search-btn.active {
            display: block;
        }

        .clear-search-btn:hover {
            background-color: #6c757d;
            color: white;
        }

        #clear-metadata-btn:hover {
            color: #495057 !important;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 onclick="showMainPage()">Tzafun</h1>
                <p>A concordance of Biblical figurative language</p>
                <p class="header-hebrew-quote">מה רב־טובך אשר־צפנת ליראיך (Psalms 31:20)</p>
            </div>
            <div class="header-attribution">
                <a onclick="showAboutPage()">about</a>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Book/Chapter Selection -->
            <section class="book-selection">
                <h3>Text Selection</h3>
                <label for="book-select">Books (Ctrl+Click to select):</label>
                <select id="book-select" multiple>
                    <option value="genesis" selected>Genesis</option>
                    <option value="exodus" selected>Exodus</option>
                    <option value="leviticus" selected>Leviticus</option>
                    <option value="numbers" selected>Numbers</option>
                    <option value="deuteronomy" selected>Deuteronomy</option>
                    <option value="psalms" selected>Psalms</option>
                </select>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.75rem;">
                    <label for="chapter-input">Chapters:</label>
                    <button onclick="document.getElementById('chapter-input').value='all'; filterAndRenderVerses();" style="background: none; border: none; color: #6c757d; font-size: 1.1rem; cursor: pointer; padding: 0; margin: 0;" title="Reset to all chapters">↻</button>
                </div>
                <input type="text" id="chapter-input" placeholder="e.g., 1,3,5-7 or 'all'">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.5rem;">
                    <label for="verse-input">Verses:</label>
                    <button onclick="document.getElementById('verse-input').value='all'; filterAndRenderVerses();" style="background: none; border: none; color: #6c757d; font-size: 1.1rem; cursor: pointer; padding: 0; margin: 0;" title="Reset to all verses">↻</button>
                </div>
                <input type="text" id="verse-input" placeholder="e.g., 1-5,10,15 or 'all'">
                <button id="load-verses" class="btn btn-primary" style="width: 100%; padding: 0.5rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; margin-top: 0.5rem; transition: all 0.2s ease;">Load Verses</button>
            </section>

            <!-- Figurative Type Filters -->
            <section class="type-filters">
                <h3>Figurative Language Types</h3>

                <!-- Select All / Clear All Buttons -->
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button id="select-all-types" style="flex: 1; padding: 0.4rem 0.8rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease;">Select All</button>
                    <button id="clear-all-types" style="flex: 1; padding: 0.4rem 0.8rem; background: white; color: #2b394f; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease;">Clear All</button>
                </div>

                <label class="tooltip">
                    <input type="checkbox" value="metaphor" checked>
                    <span class="filter-color metaphor"></span>
                    Metaphor
                    <span class="tooltiptext">A comparison where one thing is said to be another (e.g., "God is my rock")</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="simile" checked>
                    <span class="filter-color simile"></span>
                    Simile
                    <span class="tooltiptext">A comparison using "like" or "as" (e.g., "like a deer pants for water")</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="personification" checked>
                    <span class="filter-color personification"></span>
                    Personification
                    <span class="tooltiptext">Giving human qualities to non-human things (e.g., "the mountains skipped like rams")</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="idiom" checked>
                    <span class="filter-color idiom"></span>
                    Idiom
                    <span class="tooltiptext">A phrase with a meaning different from its literal words (e.g., "fruit of the womb")</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="hyperbole" checked>
                    <span class="filter-color hyperbole"></span>
                    Hyperbole
                    <span class="tooltiptext">Exaggeration for emphasis (e.g., "rivers of tears flow from my eyes")</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="metonymy" checked>
                    <span class="filter-color metonymy"></span>
                    Metonymy
                    <span class="tooltiptext">Using one thing to represent another closely related thing (e.g., "the sword" for war)</span>
                </label>
                <label class="tooltip">
                    <input type="checkbox" value="other" checked>
                    <span class="filter-color other"></span>
                    Other
                    <span class="tooltiptext">Other forms of figurative language not fitting the main categories</span>
                </label>
                <label>
                    <input type="checkbox" value="not_figurative">
                    <span class="filter-color" style="background-color: #6c757d;"></span>
                    Not Figurative
                </label>
            </section>

            <!-- Text Version Toggle -->
            <section class="text-options">
                <h3 class="tooltip">Text Version
                    <span class="tooltiptext">See About section for details</span>
                </h3>
                <div style="margin-bottom: 1rem;">
                    <strong>Hebrew:</strong><br>
                    <label><input type="radio" name="hebrew-version" value="sacred" checked> Sacred Names</label>
                    <label><input type="radio" name="hebrew-version" value="non-sacred"> Traditional Jewish</label>
                </div>
                <div>
                    <strong>English:</strong><br>
                    <label><input type="radio" name="english-version" value="sacred" checked> Sacred Names</label>
                    <label><input type="radio" name="english-version" value="non-sacred"> Traditional Jewish</label>
                </div>
            </section>

            <!-- Advanced Search -->
            <section class="advanced-search">
                <h3>Search Biblical Text</h3>

                <!-- Search Type Toggle -->
                <div class="search-type-toggle">
                    <button class="toggle-btn" id="english-toggle" onclick="toggleSearchType('english')">English</button>
                    <button class="toggle-btn active" id="hebrew-toggle" onclick="toggleSearchType('hebrew')">עברית</button>
                </div>

                <!-- Search Input with Clear and Keyboard Toggle -->
                <div class="search-input-container">
                    <input type="text" id="search-input" placeholder="Search Hebrew text...">
                    <button class="clear-search-btn" id="clear-search-btn" onclick="clearTextSearch()" title="Clear Search">↻</button>
                    <button class="keyboard-toggle" id="keyboard-toggle" onclick="toggleHebrewKeyboard()" title="Toggle Hebrew Keyboard">⌨</button>
                </div>

                <!-- Hebrew Virtual Keyboard - Compact rectangular layout -->
                <div class="hebrew-keyboard" id="hebrew-keyboard">
                    <!-- Row 1: 9 letters -->
                    <div class="hebrew-key" onclick="insertHebrew('א')">א</div>
                    <div class="hebrew-key" onclick="insertHebrew('ב')">ב</div>
                    <div class="hebrew-key" onclick="insertHebrew('ג')">ג</div>
                    <div class="hebrew-key" onclick="insertHebrew('ד')">ד</div>
                    <div class="hebrew-key" onclick="insertHebrew('ה')">ה</div>
                    <div class="hebrew-key" onclick="insertHebrew('ו')">ו</div>
                    <div class="hebrew-key" onclick="insertHebrew('ז')">ז</div>
                    <div class="hebrew-key" onclick="insertHebrew('ח')">ח</div>
                    <div class="hebrew-key" onclick="insertHebrew('ט')">ט</div>
                    <!-- Row 2: 9 letters -->
                    <div class="hebrew-key" onclick="insertHebrew('י')">י</div>
                    <div class="hebrew-key" onclick="insertHebrew('כ')">כ</div>
                    <div class="hebrew-key" onclick="insertHebrew('ל')">ל</div>
                    <div class="hebrew-key" onclick="insertHebrew('מ')">מ</div>
                    <div class="hebrew-key" onclick="insertHebrew('נ')">נ</div>
                    <div class="hebrew-key" onclick="insertHebrew('ס')">ס</div>
                    <div class="hebrew-key" onclick="insertHebrew('ע')">ע</div>
                    <div class="hebrew-key" onclick="insertHebrew('פ')">פ</div>
                    <div class="hebrew-key" onclick="insertHebrew('צ')">צ</div>
                    <!-- Row 3: 9 letters (4 regular + 5 final forms) -->
                    <div class="hebrew-key" onclick="insertHebrew('ק')">ק</div>
                    <div class="hebrew-key" onclick="insertHebrew('ר')">ר</div>
                    <div class="hebrew-key" onclick="insertHebrew('ש')">ש</div>
                    <div class="hebrew-key" onclick="insertHebrew('ת')">ת</div>
                    <div class="hebrew-key" onclick="insertHebrew('ך')">ך</div>
                    <div class="hebrew-key" onclick="insertHebrew('ם')">ם</div>
                    <div class="hebrew-key" onclick="insertHebrew('ן')">ן</div>
                    <div class="hebrew-key" onclick="insertHebrew('ף')">ף</div>
                    <div class="hebrew-key" onclick="insertHebrew('ץ')">ץ</div>
                    <!-- Row 4: Action keys -->
                    <div class="hebrew-key action" onclick="clearSearch()" style="grid-column: span 2;">Clear</div>
                    <div class="hebrew-key" onclick="insertHebrew(' ')" style="grid-column: span 5;">Space</div>
                    <div class="hebrew-key action" onclick="deleteLastChar()" style="grid-column: span 2;">⌫</div>
                </div>

                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 1.5rem; margin-bottom: 0.5rem;">
                    <h4 class="tooltip" style="color: #2b394f; margin: 0; font-size: 1rem; border-bottom: 2px solid #2b394f; padding-bottom: 0.3rem; flex: 1;">Search for Tag
                        <span class="tooltiptext">See About section for details</span>
                    </h4>
                    <button id="clear-metadata-btn" onclick="clearMetadataSearch()" style="background: none; border: none; color: #6c757d; font-size: 1.2rem; cursor: pointer; padding: 0; margin: 0 0 0 0.5rem;" title="Clear tag search">↻</button>
                </div>
                <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.5rem; margin-bottom: 0.75rem;">For multiple search terms, separate with semicolons (e.g., "God;Divine")</div>
                <div class="metadata-search" style="margin-top: 0;">
                    <input type="text" id="target-search" placeholder="Target">
                    <input type="text" id="vehicle-search" placeholder="Vehicle">
                    <input type="text" id="ground-search" placeholder="Ground">
                    <input type="text" id="posture-search" placeholder="Posture">
                </div>
            </section>
        </aside>

        <!-- Main Content -->
        <main class="main-content" id="main-content">
            <div id="verses-container">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                </div>
            </div>

            <!-- Stats and Navigation Bar at Bottom -->
            <div class="stats-bar" id="stats-bar">
                Loading...
            </div>
        </main>

        <!-- About Page -->
        <div class="about-page" id="about-page">
            <!-- Table of Contents -->
            <div class="about-toc">
                <h3>Contents</h3>
                <ul>
                    <li><a href="#section-tzafun">Tzafun</a></li>
                    <li><a href="#section-information">The information in Tzafun</a></li>
                    <li><a href="#section-documentation">More documentation</a></li>
                    <li><a href="#section-acknowledgements">Acknowledgements</a></li>
                </ul>
            </div>

            <!-- Main Content -->
            <div class="about-content">
                <h2 id="section-tzafun">Tzafun</h2>
                <p>"Tzafun" (צָפֻן) means "hidden" or "concealed" and also implies treasure, as in Psalms 31:20: "How abundant is the good that You have in store (צָפַ֢נְתָּ) for those who fear You" and Psalm 119:11: "I have treasured (צָפַ֣נְתִּי) Your word in my heart."</p>
                <p>Tzafun originated with the question - couldn't we use powerful AI tools to compile a 'concordance' of biblical figurative speech? Tzafun was created by having large language models "read" the text of the Bible verse by verse, in English and Hebrew, and tag instances of figurative speech, including similes, metaphors, hyperbole, idioms, personification and metonymy.</p>
                <p>This is a two-stage process. A first AI agent reads the verse, deliberates and identifies figurative speech. A second AI agent reviews the work of the first, validating, invalidating or reclassifying the initial tags. Tzafun records the final result, as well as the deliberations of both agents.</p>

                <h2 id="section-information">The information in Tzafun</h2>
                <p>Each verse is shown in Hebrew (Masoretic) and English (JPS 2006). Examples of figurative speech that were identified by the first agent and validated by the second are highlighted. If you click on the header above any verse, you can see the LLM's deliberations. If you click on a highlighted example of figurative speech, you can also see the following information:</p>
                <p><strong>Target</strong> what or who the figurative speech is about</p>
                <p><strong>Vehicle</strong> what the target is being likened to</p>
                <p><strong>Ground</strong> what quality of the target is being illuminated by the figurative speech</p>
                <p><strong>Posture</strong> purpose of the speech; emotional valence</p>
                <p>Example: "כִּֽי־עָפָ֣ר אַ֔תָּה"/ "For dust you are" (Gen 3:19). Target = humans; Vehicle = dust; Ground = humble origin, ephemerality; Posture = solemn declaration</p>
                <p>To make these easier to search, the LLM was instructed to generate a hierarchy of tags for each of these fields. For example, if the vehicle of the metaphor is bees, the LLM will record "bees → insects → animals". A search for any of these terms will identify Psalms 118:12 "סַבּ֤וּנִי כִדְבוֹרִ֗ים"/ "They have beset me like bees".</p>
                <p><strong>Explanation</strong> The LLM's explanation of the figurative speech.</p>
                <p><strong>Validation reasons</strong> The second agent's deliberations about whether to validate/invalidate/reclassify a phrase tagged by the first agent as figurative speech.</p>
                <p><strong>Speaker</strong> The LLM's assessment of who is speaking the figurative language.</p>
                <p><strong>Confidence</strong> The LLM's level of confidence that this is figurative language.</p>
                <p><strong>Name of the model</strong> Most verses were processed by Gemini-2.5-flash. However, this model struggled to process about 10% of verses, and it returned incomplete deliberations. When this happened, we used Gemini-2.5-pro as a fallback. When this failed (well under 1% of the time), Claude-Sonnet-4 was used.</p>

                <h2 id="section-documentation">More documentation</h2>
                <p>[We'll add to this later.]</p>

                <h2 id="section-acknowledgements">Acknowledgements</h2>
                <p>Text from Sefaria.org.</p>
                <p>Hebrew: Miqra According to the Masorah (MAM).</p>
                <p>English: Jewish Publication Society, 2006.</p>
            </div>
        </div>

        <!-- Bottom Detail Panel -->
        <div class="detail-panel" id="detail-panel">
            <div class="panel-header">
                <h3>Verse Details: <span id="selected-verse"></span></h3>
                <button class="close-btn" id="close-panel">&times;</button>
            </div>

            <div class="panel-content">
                <div class="deliberation-section">
                    <h4>Figurative Detection Deliberation</h4>
                    <p id="deliberation-text">Click on a verse to see the AI's deliberation process...</p>
                    <span class="model-badge" id="model-used"></span>
                </div>

                <div class="annotation-details" id="annotation-details">
                    <!-- Dynamically populated when annotation is clicked -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const appState = {
            verses: [],
            filteredVerses: [],
            selectedTypes: new Set(['metaphor', 'simile', 'personification', 'idiom', 'hyperbole', 'metonymy', 'other']),
            showNotFigurative: false,
            hebrewVersion: 'sacred',
            englishVersion: 'sacred',
            searchType: 'hebrew', // 'hebrew' or 'english'
            currentSearch: {
                text: '',
                target: '',
                vehicle: '',
                ground: '',
                posture: ''
            },
            pagination: {
                limit: 25,
                offset: 0,
                total: 0,
                hasMore: false,
                total_figurative_instances: 0,
                countIsEstimate: false  // Track if count is an estimate
            },
            loading: false,
            requestCounter: 0,  // Track request order to handle race conditions
            countRequestCounter: 0  // Track background count requests
        };

        // API Configuration - use relative URL to work in both dev and production
        const API_BASE = '/api';

        // Page Navigation Functions
        function showAboutPage() {
            document.getElementById('main-content').style.display = 'none';
            document.querySelector('.sidebar').style.display = 'none';
            document.getElementById('about-page').classList.add('active');
            document.getElementById('about-page').style.gridColumn = '1 / -1';
        }

        function showMainPage() {
            document.getElementById('main-content').style.display = 'block';
            document.querySelector('.sidebar').style.display = 'block';
            document.getElementById('about-page').classList.remove('active');
        }

        // DOM Elements
        const elements = {
            versesContainer: document.getElementById('verses-container'),
            detailPanel: document.getElementById('detail-panel'),
            selectedVerse: document.getElementById('selected-verse'),
            deliberationText: document.getElementById('deliberation-text'),
            modelUsed: document.getElementById('model-used'),
            annotationDetails: document.getElementById('annotation-details'),
            statsBar: document.getElementById('stats-bar'),
            loadBtn: document.getElementById('load-verses'),
            closePanel: document.getElementById('close-panel')
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            loadStatistics();
            loadDefaultVerses(); // Load verses immediately
        });

        function initializeEventListeners() {
            // Type filter checkboxes
            document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.value === 'not_figurative') {
                        appState.showNotFigurative = this.checked;
                    } else {
                        if (this.checked) {
                            appState.selectedTypes.add(this.value);
                        } else {
                            appState.selectedTypes.delete(this.value);
                        }
                    }
                    filterAndRenderVerses();
                });
            });

            // Text version radio buttons
            document.querySelectorAll('input[name="hebrew-version"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    appState.hebrewVersion = this.value;
                    renderVerses();
                });
            });

            document.querySelectorAll('input[name="english-version"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    appState.englishVersion = this.value;
                    renderVerses();
                });
            });

            // Search inputs
            document.getElementById('search-input').addEventListener('input', function() {
                updateClearButtonVisibility();
                debounce(handleSearch, 300)();
            });
            // Metadata search listeners
            // Metadata search event listeners - auto-uncheck "Not Figurative" when metadata search is active
            document.getElementById('target-search').addEventListener('input', function() {
                if (this.value.trim()) {
                    uncheckNotFigurativeForMetadataSearch();
                }
                debounce(handleSearch, 300)();
            });
            document.getElementById('vehicle-search').addEventListener('input', function() {
                if (this.value.trim()) {
                    uncheckNotFigurativeForMetadataSearch();
                }
                debounce(handleSearch, 300)();
            });
            document.getElementById('ground-search').addEventListener('input', function() {
                if (this.value.trim()) {
                    uncheckNotFigurativeForMetadataSearch();
                }
                debounce(handleSearch, 300)();
            });
            document.getElementById('posture-search').addEventListener('input', function() {
                if (this.value.trim()) {
                    uncheckNotFigurativeForMetadataSearch();
                }
                debounce(handleSearch, 300)();
            });

            // Panel controls
            elements.closePanel.addEventListener('click', closeDetailPanel);
            elements.loadBtn.addEventListener('click', loadVerses);

            // Select All / Clear All buttons for figurative language types
            document.getElementById('select-all-types').addEventListener('click', function() {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (!checkbox.checked) {
                        checkbox.checked = true;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = true;
                        } else {
                            appState.selectedTypes.add(checkbox.value);
                        }
                    }
                });
                filterAndRenderVerses();
            });

            document.getElementById('clear-all-types').addEventListener('click', function() {
                document.querySelectorAll('.type-filters input[type="checkbox"]').forEach(checkbox => {
                    if (checkbox.checked) {
                        checkbox.checked = false;
                        if (checkbox.value === 'not_figurative') {
                            appState.showNotFigurative = false;
                        } else {
                            appState.selectedTypes.delete(checkbox.value);
                        }
                    }
                });
                filterAndRenderVerses();
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function uncheckNotFigurativeForMetadataSearch() {
            // Auto-uncheck "Not Figurative" when metadata search is active to avoid complex queries
            const notFigCheckbox = document.querySelector('input[value="not_figurative"]');
            if (notFigCheckbox && notFigCheckbox.checked) {
                notFigCheckbox.checked = false;
                appState.showNotFigurative = false;
            }
        }

        function handleSearch() {
            appState.currentSearch = {
                text: document.getElementById('search-input').value,
                target: document.getElementById('target-search').value,
                vehicle: document.getElementById('vehicle-search').value,
                ground: document.getElementById('ground-search').value,
                posture: document.getElementById('posture-search').value
            };
            filterAndRenderVerses();
        }

        // Hebrew Keyboard Functions
        function toggleSearchType(type) {
            appState.searchType = type;
            const hebrewToggle = document.getElementById('hebrew-toggle');
            const englishToggle = document.getElementById('english-toggle');
            const searchInput = document.getElementById('search-input');
            const keyboardToggle = document.getElementById('keyboard-toggle');

            if (type === 'hebrew') {
                hebrewToggle.classList.add('active');
                englishToggle.classList.remove('active');
                searchInput.placeholder = 'Search Hebrew text...';
                searchInput.style.direction = 'rtl';
                searchInput.style.textAlign = 'right';
                keyboardToggle.style.display = 'block';
            } else {
                englishToggle.classList.add('active');
                hebrewToggle.classList.remove('active');
                searchInput.placeholder = 'Search English text...';
                searchInput.style.direction = 'ltr';
                searchInput.style.textAlign = 'left';
                keyboardToggle.style.display = 'none';
                document.getElementById('hebrew-keyboard').classList.remove('active');
            }

            // Clear search when switching types
            const hadSearch = searchInput.value !== '';
            searchInput.value = '';
            updateClearButtonVisibility();

            // Only trigger search if there was actually a search term to clear
            if (hadSearch) {
                handleSearch();
            }
        }

        function toggleHebrewKeyboard() {
            const keyboard = document.getElementById('hebrew-keyboard');
            keyboard.classList.toggle('active');
        }

        function insertHebrew(char) {
            const input = document.getElementById('search-input');
            const cursorPos = input.selectionStart;
            const value = input.value;
            input.value = value.substring(0, cursorPos) + char + value.substring(cursorPos);
            input.setSelectionRange(cursorPos + char.length, cursorPos + char.length);
            input.focus();
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearSearch() {
            document.getElementById('search-input').value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function clearTextSearch() {
            const input = document.getElementById('search-input');
            input.value = '';
            updateClearButtonVisibility();
            handleSearch();
        }

        function deleteLastChar() {
            const input = document.getElementById('search-input');
            if (input.value.length > 0) {
                input.value = input.value.slice(0, -1);
                updateClearButtonVisibility();
                handleSearch();
            }
        }

        function updateClearButtonVisibility() {
            const input = document.getElementById('search-input');
            const clearBtn = document.getElementById('clear-search-btn');
            if (input.value.length > 0) {
                clearBtn.classList.add('active');
            } else {
                clearBtn.classList.remove('active');
            }
        }

        function clearMetadataSearch() {
            document.getElementById('target-search').value = '';
            document.getElementById('vehicle-search').value = '';
            document.getElementById('ground-search').value = '';
            document.getElementById('posture-search').value = '';
            handleSearch();
        }

        // API Functions
        async function makeAPICall(endpoint, params = {}) {
            try {
                // Build URL with query parameters - use relative URL directly with fetch
                const url = new URL(`${API_BASE}${endpoint}`, window.location.origin);
                Object.keys(params).forEach(key => {
                    if (params[key] !== '' && params[key] !== null && params[key] !== undefined) {
                        url.searchParams.append(key, params[key]);
                    }
                });

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                return null;
            }
        }

        // Database selection functions removed - now using fixed database

        async function loadStatistics() {
            try {
                const stats = await makeAPICall('/statistics');
                if (stats) {
                    console.log('Database statistics:', stats);
                    // Update book selection options
                    updateBookOptions(stats.books);
                }
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        function updateBookOptions(books) {
            const bookSelect = document.getElementById('book-select');

            // Only update if the book select is empty or has different books
            if (bookSelect.options.length === 0) {
                bookSelect.innerHTML = '';
                // Biblical order
                const biblicalOrder = ['Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy', 'Psalms'];
                biblicalOrder.forEach(book => {
                    if (books.includes(book)) {
                        const option = document.createElement('option');
                        option.value = book.toLowerCase();
                        option.textContent = book;
                        option.selected = true; // Select all by default
                        bookSelect.appendChild(option);
                    }
                });
            }
        }

        async function loadDefaultVerses() {
            // Load all books in biblical order by default
            await loadVersesFromAPI({
                books: 'genesis,exodus,leviticus,numbers,deuteronomy,psalms',
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                limit: 25,
                offset: 0
            });
        }

        async function loadVersesFromAPI(params = {}) {
            // Increment request counter to track this specific request
            appState.requestCounter++;
            const thisRequestId = appState.requestCounter;

            appState.loading = true;
            showLoading();

            try {
                const data = await makeAPICall('/verses', params);

                // Only process results if this is still the most recent request
                // This prevents race conditions where an older request completes after a newer one
                if (thisRequestId === appState.requestCounter && data) {
                    appState.verses = data.verses;
                    // Convert API response to frontend format
                    appState.pagination = {
                        ...data.pagination,
                        hasMore: data.pagination.has_more, // Convert snake_case to camelCase
                        total_figurative_instances: data.pagination.total_figurative_instances || 0
                    };

                    // Check if count is an estimate (0 instances = mixed query estimate)
                    // This happens when show_all_verses or show_not_figurative is enabled
                    const show_all_verses = appState.selectedTypes.size === 7 && appState.showNotFigurative;
                    const show_not_figurative = appState.showNotFigurative;
                    const isEstimate = (data.pagination.total_figurative_instances === 0 && (show_all_verses || show_not_figurative));
                    appState.pagination.countIsEstimate = isEstimate;

                    appState.filteredVerses = appState.verses; // API already filters
                    renderVerses();
                    updateStats();

                    // Trigger lazy count loading if estimate
                    if (isEstimate) {
                        loadExactCount(params);
                    }
                } else if (thisRequestId !== appState.requestCounter) {
                    // This request was superseded by a newer one, ignore results
                    console.log(`Ignoring stale API response (request ${thisRequestId}, current ${appState.requestCounter})`);
                } else if (!data) {
                    showError('Failed to load verses. Please ensure the API server is running.');
                }
            } catch (error) {
                // Only show error if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    console.error('Failed to load verses:', error);
                    showError('Failed to load verses. Please check your connection and try again.');
                }
            } finally {
                // Only clear loading state if this is still the most recent request
                if (thisRequestId === appState.requestCounter) {
                    appState.loading = false;
                }
            }
        }

        async function loadExactCount(params) {
            // Increment count request counter
            appState.countRequestCounter++;
            const thisCountRequestId = appState.countRequestCounter;

            try {
                // Build params for count endpoint (exclude limit and offset)
                const countParams = { ...params };
                delete countParams.limit;
                delete countParams.offset;

                console.log('Loading exact count in background...');
                const data = await makeAPICall('/verses/count', countParams);

                // Only update if this is still the most recent count request
                if (thisCountRequestId === appState.countRequestCounter && data) {
                    appState.pagination.total = data.total;
                    appState.pagination.total_figurative_instances = data.total_figurative_instances;
                    appState.pagination.countIsEstimate = false;
                    updateStats(); // Refresh display with exact count
                    console.log(`Exact count loaded: ${data.total} verses, ${data.total_figurative_instances} instances`);
                }
            } catch (error) {
                console.error('Failed to load exact count:', error);
                // Silently fail - estimate is good enough
            }
        }

        function showLoading() {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading verses...</p>
                    <p style="font-size: 0.9rem; opacity: 0.7; margin-top: 0.5rem;">First load may take up to 1 minute</p>
                </div>
            `;
        }

        function showError(message) {
            elements.versesContainer.innerHTML = `
                <div class="loading">
                    <p style="color: #e74c3c;">⚠️ ${message}</p>
                    <button onclick="loadDefaultVerses()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #2b394f; color: white; border: 1px solid #2b394f; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;">
                        Try Again
                    </button>
                </div>
            `;
        }

        function filterAndRenderVerses() {
            // Check if user has selected nothing (clear all scenario)
            if (appState.selectedTypes.size === 0 && !appState.showNotFigurative) {
                // Show NO verses when clear all is pressed (user's request)
                elements.versesContainer.innerHTML = '<div class="loading"><p>No figurative language types selected. Please select at least one type to see verses.</p></div>';
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        No verses displayed - no figurative language types selected
                    </div>
                    <div></div>
                `;
                return;
            }

            // Reset pagination offset when filter changes
            appState.pagination.offset = 0;

            // Since filtering is now done server-side, we just need to reload with current filters
            const params = buildAPIParams();
            loadVersesFromAPI(params);
        }

        function buildAPIParams() {
            const books = Array.from(document.getElementById('book-select').selectedOptions).map(opt => opt.value);
            const chapters = document.getElementById('chapter-input').value;
            const verses = document.getElementById('verse-input').value;

            return {
                books: books.join(','),
                chapters: chapters || 'all',
                verses: verses || 'all',
                figurative_types: Array.from(appState.selectedTypes).join(','),
                show_not_figurative: appState.showNotFigurative,
                search_hebrew: appState.searchType === 'hebrew' ? appState.currentSearch.text : '',
                search_english: appState.searchType === 'english' ? appState.currentSearch.text : '',
                search_target: appState.currentSearch.target,
                search_vehicle: appState.currentSearch.vehicle,
                search_ground: appState.currentSearch.ground,
                search_posture: appState.currentSearch.posture,
                limit: appState.pagination.limit,
                offset: appState.pagination.offset
            };
        }

        function cleanHebrewText(text) {
            if (!text) return text;


            // CONSERVATIVE approach: Since API returns clean data, do minimal cleaning

            // Check if text is already clean Hebrew (>80% Hebrew characters)
            const hebrewChars = (text.match(/[\u0590-\u05FF]/g) || []).length;
            const totalChars = text.replace(/\s/g, '').length;

            if (totalChars > 0 && hebrewChars / totalChars > 0.8) {
                // Text is already clean Hebrew, just do basic HTML entity cleanup
                return text
                    .replace(/&nbsp;/g, ' ')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"')
                    .replace(/&#x?\d+;/g, '')
                    .replace(/\s{2,}/g, ' ')
                    .trim();
            }

            // Only if text appears contaminated, do more aggressive cleaning
            let processed = text
                // Basic HTML entity cleanup
                .replace(/&nbsp;/g, ' ')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"')
                .replace(/&#x?\d+;/g, '')
                // Remove only clearly problematic patterns
                .replace(/json","[^"]*"/g, '')
                .replace(/verse_model_used[^}]*/g, '')
                .replace(/\\n\s*/g, ' ')
                .replace(/\s{2,}/g, ' ')
                .trim();

            // If result contains substantial Hebrew content, return it
            const cleanedHebrewChars = (processed.match(/[\u0590-\u05FF]/g) || []).length;
            const cleanedTotalChars = processed.replace(/\s/g, '').length;

            if (cleanedTotalChars > 0 && cleanedHebrewChars / cleanedTotalChars > 0.3) {
                return processed;
            }

            // If still problematic, return original text (let display handle it)
            return text;
        }

        function highlightSearchTerms(text, searchTerm, isHebrew = false) {
            if (!searchTerm || !text) return text;

            // For Hebrew, we need to match with and without vowel points/cantillation
            if (isHebrew) {
                // Function to strip Hebrew vowel points and cantillation marks
                const stripHebrewMarks = (str) => str.replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '');

                // Split by HTML tags to avoid highlighting inside tag attributes
                const parts = text.split(/(<[^>]+>)/);

                return parts.map((part, index) => {
                    // Don't modify HTML tags (including attributes)
                    if (part.startsWith('<') && part.endsWith('>')) {
                        return part;
                    }

                    // Strip marks from both search term and text for comparison
                    const strippedPart = stripHebrewMarks(part);
                    const strippedTerm = stripHebrewMarks(searchTerm);

                    if (strippedPart.includes(strippedTerm)) {
                        // Find all occurrences with marks stripped, but highlight with original marks
                        const escapedTerm = strippedTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        // Create regex that allows vowel points between each letter
                        const flexiblePattern = escapedTerm.split('').join('[\\u0591-\\u05C7\\u05F0-\\u05F4]*');
                        const regex = new RegExp(`(${flexiblePattern})`, 'g');
                        return part.replace(regex, '<span class="search-highlight">$1</span>');
                    }

                    return part;
                }).join('');
            } else {
                // English highlighting - now works inside figurative text too
                const parts = text.split(/(<[^>]+>)/);

                return parts.map((part, index) => {
                    // Don't modify HTML tags (including attributes)
                    if (part.startsWith('<') && part.endsWith('>')) {
                        return part;
                    }

                    // Apply highlighting to all matching text
                    if (searchTerm && part.toLowerCase().includes(searchTerm.toLowerCase())) {
                        const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(`(${escapedTerm})`, 'gi');
                        return part.replace(regex, '<span class="search-highlight">$1</span>');
                    }

                    return part;
                }).join('');
            }
        }

        function renderVerses() {
            if (appState.filteredVerses.length === 0) {
                elements.versesContainer.innerHTML = '<div class="loading"><p>No verses match your current filters.</p></div>';
                return;
            }

            const versesHTML = appState.filteredVerses.map(verse => {

                let hebrewText = cleanHebrewText(appState.hebrewVersion === 'sacred' ? verse.hebrew_text : verse.hebrew_text_non_sacred);


                // If Hebrew text is empty after cleaning (heavily contaminated), try the stripped version
                if (!hebrewText && verse.hebrew_text_stripped) {
                    hebrewText = cleanHebrewText(verse.hebrew_text_stripped);
                }

                // If still empty, show a placeholder
                if (!hebrewText) {
                    hebrewText = '[Hebrew text unavailable - contaminated data]';
                }

                const englishText = appState.englishVersion === 'sacred' ? verse.english_text_clean : verse.english_text_clean_non_sacred;

                // Add verse information to each annotation for synchronization
                const annotationsWithVerseInfo = verse.annotations.map(annotation => ({
                    ...annotation,
                    verse_reference: verse.reference,
                    verse_id: verse.id,
                    verse_deliberation: verse.figurative_detection_deliberation,
                    verse_model_used: verse.model_used
                }));

                // Apply figurative highlighting first, then search highlighting
                let processedEnglish = highlightAnnotations(englishText, annotationsWithVerseInfo, 'english');
                let processedHebrew = highlightAnnotations(hebrewText, annotationsWithVerseInfo, 'hebrew');

                // Apply search term highlighting (pink) - with language-specific handling
                const searchTerm = appState.currentSearch.text;
                if (searchTerm) {
                    if (appState.searchType === 'english') {
                        processedEnglish = highlightSearchTerms(processedEnglish, searchTerm, false);
                    } else if (appState.searchType === 'hebrew') {
                        processedHebrew = highlightSearchTerms(processedHebrew, searchTerm, true);
                    }
                }

                return `
                    <div class="verse-container">
                        <div class="verse-header" onclick="showVerseDetails('${verse.reference}', ${verse.id})">
                            ${verse.reference}
                        </div>
                        <div class="verse-content">
                            <div class="english-text">
                                ${processedEnglish}
                            </div>
                            <div class="hebrew-text">
                                ${processedHebrew}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            elements.versesContainer.innerHTML = versesHTML;

            // Add click listeners to highlighted figurative text
            document.querySelectorAll('.figurative-highlight').forEach(element => {
                element.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const annotation = JSON.parse(this.dataset.annotation);
                    showAnnotationDetails(annotation);
                });
            });
        }

        function createSimpleHighlight(matchedText, cleanAnnotation) {

            // ALWAYS show highlighting regardless of selection - as requested by user
            const visibleTypes = cleanAnnotation.types || [];

            // Always show highlighting even if no types are selected
            if (visibleTypes.length === 0) {
                return matchedText;
            }

            // Create tooltip content with type indicators
            const typeIndicators = visibleTypes.map(type => {
                const typeDisplayName = type.charAt(0).toUpperCase() + type.slice(1);
                return `<span class="type-indicator"><span class="type-color-square ${type}"></span>${typeDisplayName}</span>`;
            }).join('');

            const tooltip = `<div class="type-tooltip">${typeIndicators}</div>`;

            // Create minimal annotation object for data-annotation (exclude large text fields)
            const minimalAnnotation = {
                figurative_text: cleanAnnotation.figurative_text,
                types: cleanAnnotation.types,
                target: cleanAnnotation.target,
                vehicle: cleanAnnotation.vehicle,
                ground: cleanAnnotation.ground,
                posture: cleanAnnotation.posture,
                speaker: cleanAnnotation.speaker,
                confidence: cleanAnnotation.confidence,
                verse_reference: cleanAnnotation.verse_reference,
                verse_id: cleanAnnotation.verse_id
                // Exclude: explanation, validation_reason_*, verse_deliberation (large fields)
            };

            // Escape the JSON for use in HTML attribute
            // Use single quotes as delimiter and escape single quotes in JSON as &#39;
            const escapedJson = JSON.stringify(minimalAnnotation)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;');

            return `<span class="figurative-highlight" data-annotation='${escapedJson}'>${matchedText}${tooltip}</span>`;
        }

        // Function removed - using simple highlighting approach instead

        function highlightAnnotations(text, annotations, language) {
            if (!text || !annotations || annotations.length === 0) {
                return text || '';
            }

            let highlightedText = text;

            // Simple helper to handle divine name differences for English non-sacred text
            function handleDivineNameVariations(figText, verseText, lang) {
                if (lang === 'english' && appState.englishVersion === 'non-sacred') {
                    // For English non-sacred, figurative_text might have יהוה but english_text_non_sacred has ה׳
                    return figText.replace(/יהוה/g, 'ה׳');
                }
                return figText;
            }

            // Helper function to extract core text from explanatory phrases
            function extractCoreText(figText) {
                if (!figText) return '';

                // Remove parenthetical explanations like "(lit. 'his hand reaches')"
                let coreText = figText.replace(/\s*\([^)]*\)/g, '');

                // Remove bracketed explanations
                coreText = coreText.replace(/\s*\[[^\]]*\]/g, '');

                // Clean up whitespace
                return coreText.replace(/\s+/g, ' ').trim();
            }

            // Filter annotations to only those that match the language and have visible types
            const relevantAnnotations = annotations.filter(annotation => {
                const rawFigurativeText = language === 'hebrew' ?
                    (appState.hebrewVersion === 'sacred' ? annotation.figurative_text_in_hebrew : annotation.figurative_text_in_hebrew_non_sacred) :
                    annotation.figurative_text;
                const figurativeText = language === 'hebrew' ? cleanHebrewText(rawFigurativeText) : rawFigurativeText;

                const visibleTypes = annotation.types.filter(type => appState.selectedTypes.has(type));

                if (!figurativeText || visibleTypes.length === 0) {
                    return false;
                }

                // Try exact match first (should work in most cases)
                if (highlightedText.includes(figurativeText)) {
                    return true;
                }

                // For Hebrew, try normalized matching (strip diacritics from both texts)
                if (language === 'hebrew') {
                    // Normalize the verse text by removing diacritics but PRESERVING word boundaries
                    const normalizedVerseText = highlightedText
                        .normalize('NFD')  // Unicode normalization to handle different combining character sequences
                        .replace(/<[^>]*>/g, '') // Remove HTML tags
                        .replace(/&nbsp;/g, ' ') // Remove entities
                        .replace(/&[a-zA-Z0-9#]+;/g, ' ')
                        .replace(/־/g, ' ')  // CRITICAL: Replace maqaf (U+05BE) BEFORE removing diacritics!
                        .replace(/[\u0591-\u05BD\u05BF-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew diacritics (excluding U+05BE)
                        .replace(/\s+/g, ' ')  // Normalize whitespace to single spaces
                        .trim();

                    // Normalize the figurative text
                    const normalizedFigText = figurativeText
                        .normalize('NFD')  // Unicode normalization to handle different combining character sequences
                        .replace(/־/g, ' ')  // CRITICAL: Replace maqaf (U+05BE) BEFORE removing diacritics!
                        .replace(/[\u0591-\u05BD\u05BF-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew diacritics (excluding U+05BE)
                        .replace(/\s+/g, ' ')  // Normalize whitespace to single spaces
                        .trim();

                    if (normalizedVerseText.includes(normalizedFigText)) {
                        return true;
                    }
                }

                // Handle divine name variations for English non-sacred
                const adjustedFigText = handleDivineNameVariations(figurativeText, highlightedText, language);
                if (adjustedFigText !== figurativeText && highlightedText.includes(adjustedFigText)) {
                    return true;
                }

                // Extract core text (remove parenthetical explanations) and try matching
                const coreText = extractCoreText(figurativeText);
                if (coreText && coreText !== figurativeText) {
                    if (highlightedText.includes(coreText)) {
                        return true;
                    }
                    // For Hebrew, also try core text with HTML tags and entities removed
                    if (language === 'hebrew') {
                        const textWithoutHTML = highlightedText
                            .replace(/<br\s*\/?>/gi, ' ') // Replace line breaks with spaces
                        .replace(/<[^>]*>/g, '') // Remove other HTML tags
                            .replace(/&nbsp;/g, ' ') // Remove non-breaking spaces
                            .replace(/&[a-zA-Z0-9#]+;/g, ' ') // Remove other HTML entities
                            .replace(/\{[^}]*\}/g, '') // Remove markup like {ס} {פ}
                        .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew vowels and cantillation marks
                            .replace(/־/g, ' ') // Replace Hebrew hyphens with spaces
                            .replace(/\s+/g, ' ') // Normalize whitespace
                            .trim();

                        const normalizedCoreText = coreText
                            .replace(/־/g, ' ') // Replace Hebrew hyphens with spaces
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew vowels and cantillation marks
                            .replace(/\s+/g, ' ')
                            .trim();

                        if (textWithoutHTML.includes(coreText) || textWithoutHTML.includes(normalizedCoreText)) {
                            return true;
                        }
                    }
                }

                // Case-insensitive match for English
                if (language === 'english' && highlightedText.toLowerCase().includes(figurativeText.toLowerCase())) {
                    return true;
                }

                // Case-insensitive match for core text in English
                if (language === 'english' && coreText && highlightedText.toLowerCase().includes(coreText.toLowerCase())) {
                    return true;
                }

                return false;
            });

            // Get verse reference for debugging (extract from current verse context)
            let verseRef = 'Unknown';
            try {
                const verseContainer = document.querySelector('.verse-container:has(.hebrew-text)');
                if (verseContainer) {
                    const headerElement = verseContainer.querySelector('.verse-header');
                    if (headerElement) {
                        verseRef = headerElement.textContent.trim();
                    }
                }
            } catch (e) {
                // Fallback: extract from text if possible
                if (annotations.length > 0 && annotations[0].verse_reference) {
                    verseRef = annotations[0].verse_reference;
                }
            }

            console.log(`[${verseRef}] Language: ${language}, Found ${relevantAnnotations.length} relevant annotations for text: "${text.substring(0, 50)}..."`);

            // Debug specific phrases - enhanced debugging for Leviticus 1:13 and 1:17
            if (text.includes('רֵיחַ') || text.includes('נִיחֹחַ') || text.includes('ליהוה') || text.includes('ליה') || verseRef.includes('Leviticus 1:1')) {
                console.log(`[${verseRef}] *** Debugging divine name phrase ***`);
                console.log(`[${verseRef}] Text:`, text);
                console.log(`[${verseRef}] Hebrew version:`, appState.hebrewVersion);
                annotations.forEach((ann, i) => {
                    const figText = language === 'hebrew' ?
                        (appState.hebrewVersion === 'sacred' ? ann.figurative_text_in_hebrew : ann.figurative_text_in_hebrew_non_sacred) :
                        ann.figurative_text;
                    console.log(`[${verseRef}] Annotation ${i+1}: "${figText}"`);
                    console.log(`[${verseRef}] Match test: ${text.includes(figText || '')}`);

                    // Test normalized matching
                    if (language === 'hebrew' && figText) {
                        const textWithoutHTML = text
                            .replace(/<[^>]*>/g, '')
                            .replace(/&nbsp;/g, ' ')
                            .replace(/&[a-zA-Z0-9#]+;/g, ' ')
                            .replace(/\{[^}]*\}/g, '')
                            .replace(/־/g, ' ')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew vowels and cantillation marks
                            .replace(/\s+/g, ' ')
                            .trim();

                        const normalizedFigText = figText
                            .replace(/־/g, ' ')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew vowels and cantillation marks
                            .replace(/\s+/g, ' ')
                            .trim();

                        console.log(`[${verseRef}] Normalized text: "${textWithoutHTML}"`);
                        console.log(`[${verseRef}] Original figText: "${figText}"`);
                        console.log(`[${verseRef}] Normalized figText: "${normalizedFigText}"`);
                        console.log(`[${verseRef}] Normalized match test: ${textWithoutHTML.includes(figText)} || ${textWithoutHTML.includes(normalizedFigText)}`);
                    }
                });
            }

            // Debug line break issues
            if (text.includes('<') || text.includes('ונשא')) {
                console.log(`[${verseRef}] *** Debugging potential line breaks ***`);
                console.log(`[${verseRef}] Raw text:`, text);
                console.log(`[${verseRef}] Text without HTML:`, text.replace(/<[^>]*>/g, ''));
            }

            // Sort by length (longest first) to avoid replacement conflicts
            relevantAnnotations.sort((a, b) => {
                const rawTextA = language === 'hebrew' ?
                    (appState.hebrewVersion === 'sacred' ? a.figurative_text_in_hebrew : a.figurative_text_in_hebrew_non_sacred) :
                    a.figurative_text;
                const rawTextB = language === 'hebrew' ?
                    (appState.hebrewVersion === 'sacred' ? b.figurative_text_in_hebrew : b.figurative_text_in_hebrew_non_sacred) :
                    b.figurative_text;
                const textA = language === 'hebrew' ? cleanHebrewText(rawTextA) : rawTextA;
                const textB = language === 'hebrew' ? cleanHebrewText(rawTextB) : rawTextB;
                return (textB || '').length - (textA || '').length;
            });

            relevantAnnotations.forEach((annotation, annIndex) => {
                const rawFigurativeText = language === 'hebrew' ?
                    (appState.hebrewVersion === 'sacred' ? annotation.figurative_text_in_hebrew : annotation.figurative_text_in_hebrew_non_sacred) :
                    annotation.figurative_text;
                const figurativeText = language === 'hebrew' ? cleanHebrewText(rawFigurativeText) : rawFigurativeText;

                // Debug logging for Numbers 1:22 annotations
                if (text.includes('לִבְנֵ֣י שִׁמְע֔וֹן')) {
                    console.log('=== ANNOTATION DEBUG ===');
                    console.log('Raw figurative text:', rawFigurativeText);
                    console.log('Cleaned figurative text:', figurativeText);
                    console.log('Full annotation object:', annotation);
                }

                // Find the best match in the actual text using simple logic
                let matchedText = null;
                const trimmedFigText = (figurativeText || '').trim();

                if (trimmedFigText) {
                    // CRITICAL FIX: Check if the match would be inside a data-annotation attribute
                    // by verifying it's not between single quotes in an attribute
                    const checkIfInAttribute = (text, searchTerm) => {
                        const index = text.indexOf(searchTerm);
                        if (index === -1) return false;

                        // Look backwards from the match to see if we're inside a data-annotation attribute
                        const before = text.substring(Math.max(0, index - 500), index);

                        // Count single quotes before the match
                        // If odd number, we're inside an attribute value
                        const quotesBeforeMatch = (before.match(/data-annotation='/g) || []).length;
                        const closingQuotesBeforeMatch = (before.match(/'>/g) || []).length;

                        return quotesBeforeMatch > closingQuotesBeforeMatch;
                    };

                    // For Hebrew, always use normalized matching (skip exact match)
                    if (language === 'hebrew') {
                        // Remove HTML tags and entities from the verse text for matching
                        const textWithoutHTML = highlightedText
                            .normalize('NFD')  // Unicode normalization
                            .replace(/<br\s*\/?>/gi, ' ') // Replace line breaks with spaces
                        .replace(/<[^>]*>/g, '') // Remove other HTML tags
                            .replace(/&nbsp;/g, ' ') // Remove non-breaking spaces
                            .replace(/&[a-zA-Z0-9#]+;/g, ' ') // Remove other HTML entities
                            .replace(/\{[^}]*\}/g, '') // Remove markup like {ס} {פ}
                            .replace(/־/g, ' ') // CRITICAL: Replace maqaf (U+05BE) with space BEFORE removing diacritics!
                            .replace(/[\u0591-\u05BD\u05BF-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew diacritics (excluding U+05BE maqaf)
                            .replace(/\s+/g, ' ') // Normalize whitespace
                            .trim();

                        // Also normalize the figurative text
                        const normalizedFigText = trimmedFigText
                            .normalize('NFD')  // Unicode normalization
                            .replace(/־/g, ' ') // CRITICAL: Replace maqaf BEFORE removing diacritics!
                            .replace(/[\u0591-\u05BD\u05BF-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew diacritics (excluding U+05BE maqaf)
                            .replace(/\s+/g, ' ')
                            .trim();

                        if (textWithoutHTML.includes(trimmedFigText) || textWithoutHTML.includes(normalizedFigText)) {
                            // Found a match, now find the original text with HTML
                            // Try with the version that matched
                            const figTextToUse = textWithoutHTML.includes(trimmedFigText) ? trimmedFigText : normalizedFigText;

                            // Build regex pattern character by character
                            // For each character, allow diacritics/HTML between them
                            // For spaces, match space OR hyphen (since we normalized hyphens to spaces)
                            let flexiblePattern = '';
                            for (let i = 0; i < figTextToUse.length; i++) {
                                const char = figTextToUse[i];
                                if (char === ' ') {
                                    // Space should match: space, hyphen, diacritics, HTML tags, entities
                                    flexiblePattern += '(?:<br\\s*\\/??>|<[^>]*>|&[a-zA-Z0-9#]+;|\\{[^}]*\\}|־|[\\u0591-\\u05BD\\u05BF-\\u05C7\\u05F0-\\u05F4]|\\s)+';
                                } else {
                                    // Escape special regex chars, then allow diacritics after
                                    const escapedChar = char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    flexiblePattern += escapedChar + '(?:<br\\s*\\/??>|<[^>]*>|&[a-zA-Z0-9#]+;|\\{[^}]*\\}|[\\u0591-\\u05BD\\u05BF-\\u05C7\\u05F0-\\u05F4])*';
                                }
                            }
                            const regex = new RegExp(flexiblePattern, 'g');
                            const match = highlightedText.match(regex);

                            if (match) {
                                matchedText = match[0];
                            }
                        }
                    }
                    // For English, try exact match first
                    else if (language === 'english') {
                        if (highlightedText.includes(trimmedFigText) && !checkIfInAttribute(highlightedText, trimmedFigText)) {
                            matchedText = trimmedFigText;
                        }
                        // Try divine name variation for non-sacred version
                        else if (appState.englishVersion === 'non-sacred') {
                            const adjustedFigText = trimmedFigText.replace(/יהוה/g, 'ה׳');
                            if (highlightedText.includes(adjustedFigText)) {
                                matchedText = adjustedFigText;
                            }
                        }
                    }

                    // Try core text (without parenthetical explanations)
                    if (!matchedText) {
                        const coreText = trimmedFigText.replace(/\s*\([^)]*\)/g, '').replace(/\s*\[[^\]]*\]/g, '').replace(/\s+/g, ' ').trim();
                        if (coreText && coreText !== trimmedFigText) {
                            if (highlightedText.includes(coreText)) {
                                matchedText = coreText;
                            }
                            // For Hebrew, also try core text with HTML tag and entity handling
                            else if (language === 'hebrew') {
                                const textWithoutHTML = highlightedText
                                    .replace(/<br\s*\/?>/gi, ' ') // Replace line breaks with spaces
                        .replace(/<[^>]*>/g, '') // Remove other HTML tags
                                    .replace(/&nbsp;/g, ' ') // Remove non-breaking spaces
                                    .replace(/&[a-zA-Z0-9#]+;/g, ' ') // Remove other HTML entities
                                    .replace(/\{[^}]*\}/g, '') // Remove markup like {ס} {פ}
                        .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '') // Remove Hebrew vowels and cantillation marks
                                    .replace(/\s+/g, ' ') // Normalize whitespace
                                    .trim();
                                if (textWithoutHTML.includes(coreText)) {
                                    const escapedCore = coreText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    const flexiblePattern = escapedCore.split('').join('(?:<br\\s*\\/??>|<[^>]*>|&[a-zA-Z0-9#]+;|\\{[^}]*\\}|־|[\\u0591-\\u05C7\\u05F0-\\u05F4]|\\s)*');
                                    const regex = new RegExp(flexiblePattern, 'g');
                                    const match = highlightedText.match(regex);
                                    if (match) {
                                        matchedText = match[0];
                                    }
                                }
                            }
                        }
                    }

                    // Try case-insensitive for English
                    if (!matchedText && language === 'english') {
                        const lowerText = highlightedText.toLowerCase();
                        const lowerFig = trimmedFigText.toLowerCase();
                        if (lowerText.includes(lowerFig)) {
                            // Find the actual case-preserved match
                            const regex = new RegExp(trimmedFigText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                            const match = highlightedText.match(regex);
                            if (match) {
                                matchedText = match[0];
                            }
                        }
                        // Try case-insensitive with core text
                        else {
                            const coreText = trimmedFigText.replace(/\s*\([^)]*\)/g, '').replace(/\s*\[[^\]]*\]/g, '').replace(/\s+/g, ' ').trim();
                            if (coreText && lowerText.includes(coreText.toLowerCase())) {
                                const regex = new RegExp(coreText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                                const match = highlightedText.match(regex);
                                if (match) {
                                    matchedText = match[0];
                                }
                            }
                        }
                    }
                }

                if (matchedText) {
                    // CRITICAL: Skip if matchedText contains HTML tags or attributes
                    // This prevents matching text inside previously-highlighted spans
                    if (matchedText.includes('<') || matchedText.includes('data-annotation') ||
                        matchedText.includes('"speaker"') || matchedText.includes('"confidence"') ||
                        matchedText.includes('&#39;')) {
                        console.warn(`[WARNING] Skipping annotation ${annIndex + 1}: matchedText contains HTML/JSON - likely matched inside existing highlight`);
                        return; // Skip this annotation
                    }

                    const visibleTypes = annotation.types.filter(type => appState.selectedTypes.has(type));

                    // DEBUG: Log what we're about to highlight
                    console.log(`[DEBUG] About to highlight:`, {
                        matchedText: matchedText,
                        matchedTextLength: matchedText.length,
                        hasHTMLTags: matchedText.includes('<'),
                        hasDataAnnotation: matchedText.includes('data-annotation'),
                        hasJSONChars: matchedText.includes('"speaker"') || matchedText.includes('"confidence"'),
                        figurativeText: annotation.figurative_text
                    });

                    // No longer needed - using simple highlighting approach

                    // Create a clean annotation object without circular references and contaminated data
                    const cleanAnnotation = {
                        figurative_text: annotation.figurative_text || '', // Keep English figurative text as-is
                        figurative_text_in_hebrew: cleanHebrewText(annotation.figurative_text_in_hebrew), // Clean Hebrew fields
                        figurative_text_in_hebrew_non_sacred: cleanHebrewText(annotation.figurative_text_in_hebrew_non_sacred), // Clean Hebrew fields
                        types: annotation.types,
                        target: annotation.target,
                        vehicle: annotation.vehicle,
                        ground: annotation.ground,
                        posture: annotation.posture,
                        explanation: annotation.explanation || '', // Keep English explanation as-is - don't apply Hebrew cleaning
                        speaker: annotation.speaker,
                        confidence: annotation.confidence,
                        validation_reason_metaphor: annotation.validation_reason_metaphor || '', // Keep English validation reasons as-is - don't apply Hebrew cleaning
                        validation_reason_simile: annotation.validation_reason_simile || '',
                        validation_reason_personification: annotation.validation_reason_personification || '',
                        validation_reason_idiom: annotation.validation_reason_idiom || '',
                        validation_reason_hyperbole: annotation.validation_reason_hyperbole || '',
                        validation_reason_metonymy: annotation.validation_reason_metonymy || '',
                        validation_reason_other: annotation.validation_reason_other || '',
                        // Add verse information for synchronization
                        verse_reference: annotation.verse_reference,
                        verse_id: annotation.verse_id,
                        verse_deliberation: annotation.verse_deliberation || '', // Keep English deliberation as-is - don't apply Hebrew cleaning
                        verse_model_used: annotation.verse_model_used
                    };

                    try {
                        // Enhanced multi-line aware replacement
                        const replacement = createSimpleHighlight(matchedText, cleanAnnotation);

                        // DEBUG: Log the replacement
                        console.log(`[DEBUG] Replacement HTML:`, replacement.substring(0, 200));

                        const beforeLength = highlightedText.length;

                        // CRITICAL FIX: Find the match position, but ensure it's not inside an attribute
                        let firstIndex = -1;
                        let searchStart = 0;

                        while (true) {
                            const foundIndex = highlightedText.indexOf(matchedText, searchStart);
                            if (foundIndex === -1) break;

                            // Check if this occurrence is inside a data-annotation attribute
                            const before = highlightedText.substring(Math.max(0, foundIndex - 1000), foundIndex);
                            const openAttr = (before.match(/data-annotation='/g) || []).length;
                            const closeAttr = (before.match(/'>/g) || []).length;

                            if (openAttr === closeAttr) {
                                // This occurrence is NOT inside an attribute - use it!
                                firstIndex = foundIndex;
                                console.log(`[DEBUG] Found match at index ${firstIndex}, NOT in attribute (open=${openAttr}, close=${closeAttr})`);
                                break;
                            } else {
                                // This occurrence IS inside an attribute - skip it
                                console.log(`[DEBUG] Skipping match at index ${foundIndex}, IS in attribute (open=${openAttr}, close=${closeAttr})`);
                                searchStart = foundIndex + matchedText.length;
                            }
                        }

                        if (firstIndex === -1) {
                            console.warn(`[WARNING] matchedText "${matchedText}" not found in visible text (only in attributes)!`);
                        } else {
                            // Replace only the first valid occurrence
                            highlightedText = highlightedText.substring(0, firstIndex) + replacement + highlightedText.substring(firstIndex + matchedText.length);
                        }

                        const afterLength = highlightedText.length;

                        console.log(`[DEBUG] Text length changed from ${beforeLength} to ${afterLength}`);
                        console.log(`Successfully highlighted annotation ${annIndex + 1}: "${matchedText}" in ${language}`);
                    } catch (error) {
                        console.error(`Error highlighting annotation ${annIndex + 1}:`, error);
                    }
                } else {
                    console.log(`Skipping annotation ${annIndex + 1}: "${trimmedFigText}" not found in ${language} text`);
                }
            });

            return highlightedText;
        }

        function showVerseDetails(reference, verseId) {
            const verse = appState.verses.find(v => v.id === verseId);
            if (!verse) return;

            elements.selectedVerse.textContent = reference;
            elements.deliberationText.textContent = verse.figurative_detection_deliberation;
            elements.modelUsed.textContent = verse.model_used;

            // Clear any previous annotation details when showing verse details
            elements.annotationDetails.innerHTML = '';

            // Remove annotation-details class and use regular panel
            elements.detailPanel.classList.remove('annotation-details');
            elements.detailPanel.classList.add('active');

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open-large');
            mainContent.classList.add('panel-open');
        }

        function showAnnotationDetails(minimalAnnotation) {
            // Find the full annotation data from appState.verses
            const verse = appState.verses.find(v => v.id === minimalAnnotation.verse_id);
            let fullAnnotation = minimalAnnotation;

            if (verse) {
                // Find the full annotation that matches this minimal one
                fullAnnotation = verse.annotations.find(ann =>
                    ann.figurative_text === minimalAnnotation.figurative_text &&
                    JSON.stringify(ann.types) === JSON.stringify(minimalAnnotation.types)
                ) || minimalAnnotation;

                // Update verse deliberation
                elements.selectedVerse.textContent = verse.reference;
                elements.deliberationText.textContent = verse.figurative_detection_deliberation || '';
                elements.modelUsed.textContent = verse.model_used || 'Unknown';
            }

            // Format validation reasons using fullAnnotation
            const validationReasons = [];
            if (fullAnnotation.validation_reason_metaphor) validationReasons.push(`Metaphor: ${fullAnnotation.validation_reason_metaphor}`);
            if (fullAnnotation.validation_reason_simile) validationReasons.push(`Simile: ${fullAnnotation.validation_reason_simile}`);
            if (fullAnnotation.validation_reason_personification) validationReasons.push(`Personification: ${fullAnnotation.validation_reason_personification}`);
            if (fullAnnotation.validation_reason_idiom) validationReasons.push(`Idiom: ${fullAnnotation.validation_reason_idiom}`);
            if (fullAnnotation.validation_reason_hyperbole) validationReasons.push(`Hyperbole: ${fullAnnotation.validation_reason_hyperbole}`);
            if (fullAnnotation.validation_reason_metonymy) validationReasons.push(`Metonymy: ${fullAnnotation.validation_reason_metonymy}`);
            if (fullAnnotation.validation_reason_other) validationReasons.push(`Other: ${fullAnnotation.validation_reason_other}`);

            const validationHTML = validationReasons.length > 0 ?
                `<div style="margin-bottom: 1rem;">
                    <strong>Validation Reasons:</strong>
                    <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        ${validationReasons.map(reason => `<li>${reason}</li>`).join('')}
                    </ul>
                </div>` : '';

            const detailsHTML = `
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <h4 style="color: var(--accent-color); margin-bottom: 1rem;">Annotation Details</h4>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <strong>Target:</strong><br>
                            <small>${Array.isArray(fullAnnotation.target) ? fullAnnotation.target.join(' → ') : (fullAnnotation.target || 'N/A')}</small>
                        </div>
                        <div>
                            <strong>Vehicle:</strong><br>
                            <small>${Array.isArray(fullAnnotation.vehicle) ? fullAnnotation.vehicle.join(' → ') : (fullAnnotation.vehicle || 'N/A')}</small>
                        </div>
                        <div>
                            <strong>Ground:</strong><br>
                            <small>${Array.isArray(fullAnnotation.ground) ? fullAnnotation.ground.join(' → ') : (fullAnnotation.ground || 'N/A')}</small>
                        </div>
                        <div>
                            <strong>Posture:</strong><br>
                            <small>${Array.isArray(fullAnnotation.posture) ? fullAnnotation.posture.join(' → ') : (fullAnnotation.posture || 'N/A')}</small>
                        </div>
                        <div>
                            <strong>Types:</strong><br>
                            <small>${fullAnnotation.types.join(', ')}</small>
                        </div>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <strong>Explanation:</strong><br>
                        <p style="margin-top: 0.5rem;">${fullAnnotation.explanation || 'No explanation available'}</p>
                    </div>

                    ${validationHTML}

                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div><strong>Speaker:</strong> ${fullAnnotation.speaker || 'N/A'}</div>
                        <div><strong>Confidence:</strong> ${fullAnnotation.confidence ? (fullAnnotation.confidence * 100).toFixed(1) + '%' : 'N/A'}</div>
                    </div>
                </div>
            `;

            elements.annotationDetails.innerHTML = detailsHTML;
            elements.detailPanel.classList.add('active', 'annotation-details');

            // Remove previous panel classes and add large panel class
            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open');
            mainContent.classList.add('panel-open-large');
        }

        function closeDetailPanel() {
            elements.detailPanel.classList.remove('active', 'annotation-details');
            elements.annotationDetails.innerHTML = '';

            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('panel-open', 'panel-open-large');
        }

        async function updateStats() {
            const currentVerses = appState.verses.length;
            const totalAnnotations = appState.verses.reduce((sum, verse) => sum + verse.annotations.length, 0);
            const totalCount = appState.pagination.total;
            const totalFigurativeInstances = appState.pagination.total_figurative_instances || 0;

            const remainingVerses = Math.max(0, totalCount - (appState.pagination.offset + currentVerses));
            const nextStart = currentVerses + 1;
            const nextEnd = Math.min(currentVerses + appState.pagination.limit, totalCount);
            const nextButton = appState.pagination.hasMore ?
                `<button class="nav-button" onclick="loadMore()">Load verses ${nextStart}-${nextEnd}</button>` :
                '<span style="color: #28a745; font-weight: 600;">✓ All verses loaded</span>';

            // Check if we're showing an estimate
            if (appState.pagination.countIsEstimate) {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances)
                        <span style="color: #6c757d; font-style: italic;">(calculating total...)</span>
                    </div>
                    <div>${nextButton}</div>
                `;
            } else {
                elements.statsBar.innerHTML = `
                    <div class="stats-text">
                        Showing ${currentVerses} verses (${totalAnnotations} figurative language instances) of ${totalCount.toLocaleString()} verses (${totalFigurativeInstances.toLocaleString()} figurative language instances)
                    </div>
                    <div>${nextButton}</div>
                `;
            }
        }

        async function loadMore() {
            if (appState.pagination.hasMore && !appState.loading) {
                // Increment request counter to track this specific request
                appState.requestCounter++;
                const thisRequestId = appState.requestCounter;

                const params = buildAPIParams();
                params.offset = appState.pagination.offset + appState.pagination.limit;

                appState.loading = true;
                try {
                    const data = await makeAPICall('/verses', params);

                    // Only process results if this is still the most recent request
                    if (thisRequestId === appState.requestCounter && data) {
                        appState.verses = [...appState.verses, ...data.verses];
                        // Convert API response to frontend format
                        appState.pagination = {
                            ...data.pagination,
                            hasMore: data.pagination.has_more // Convert snake_case to camelCase
                        };
                        appState.filteredVerses = appState.verses;
                        renderVerses();
                        updateStats();
                    } else if (thisRequestId !== appState.requestCounter) {
                        console.log(`Ignoring stale loadMore response (request ${thisRequestId}, current ${appState.requestCounter})`);
                    }
                } catch (error) {
                    if (thisRequestId === appState.requestCounter) {
                        console.error('Failed to load more verses:', error);
                    }
                } finally {
                    if (thisRequestId === appState.requestCounter) {
                        appState.loading = false;
                    }
                }
            }
        }

        async function loadVerses() {
            // Reset pagination and load fresh data
            appState.pagination.offset = 0;
            const params = buildAPIParams();
            await loadVersesFromAPI(params);
        }
    </script>
</body>
</html>