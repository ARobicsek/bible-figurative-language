<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Reproduction Script Debug</title>
</head>

<body>
    <h1>Reproduction Script</h1>
    <div id="results">Running tests...</div>

    <script>
        class TextHighlighter {
            // Maps indices from a source string to a "cleaned" string (e.g., HTML -> Plain)
            // returns { text: string, map: [] } where map[cleanIndex] = sourceIndex
            static buildMap(sourceText) {
                let cleanText = '';
                const map = [];

                let i = 0;
                while (i < sourceText.length) {
                    const char = sourceText[i];

                    // Check for HTML tag
                    if (char === '<') {
                        const tagMatch = sourceText.substring(i).match(/^<[^>]+>/);
                        if (tagMatch) {
                            const tag = tagMatch[0].toLowerCase();
                            // If it's a block-level-ish tag or break, add a space to avoid merging words
                            // e.g. "word<br>word" -> "word word", "end</div><div>start" -> "end start"
                            if (tag.includes('<br') || tag.includes('<div') || tag.includes('<p') || tag.includes('</div') || tag.includes('</p')) {
                                // Add a space in the plain text mapped to this tag start
                                map.push(i);
                                cleanText += ' ';
                            }

                            i += tagMatch[0].length;
                            continue;
                        }
                    }

                    // Check for common HTML entities
                    if (char === '&') {
                        const entityMatch = sourceText.substring(i).match(/^&([a-zA-Z0-9#]+);/);
                        if (entityMatch) {
                            const entity = entityMatch[1];
                            let decoded = ' ';
                            if (entity === 'nbsp') decoded = ' ';
                            else if (entity === 'amp') decoded = '&';
                            else if (entity === 'lt') decoded = '<';
                            else if (entity === 'gt') decoded = '>';
                            else if (entity === 'quot') decoded = '"';
                            else if (entity === 'apos') decoded = "'";

                            // Map the start of the entity to this decoded char
                            map.push(i);
                            cleanText += decoded;
                            i += entityMatch[0].length;
                            continue;
                        }
                    }

                    // Regular char
                    map.push(i);
                    cleanText += char;
                    i++;
                }

                return { text: cleanText, map };
            }

            // Step 2: Normalize the Plain Text (Plain -> Normalized)
            static buildNormalizationMap(plainText, language) {
                let normalizedText = '';
                const map = []; // map[normIndex] = plainIndex

                for (let i = 0; i < plainText.length; i++) {
                    const char = plainText[i];

                    if (language === 'hebrew') {
                        // Hebrew Logic
                        if (/[\u0591-\u05C7\u05F0-\u05F4]/.test(char)) {
                            // Skip diacritic
                            continue;
                        }
                        if (char === '־') {
                            map.push(i);
                            normalizedText += ' ';
                            continue;
                        }
                        map.push(i);
                        normalizedText += char;
                    } else {
                        // English Logic - STRICTER normalization
                        // Skip ALL punctuation, brackets, parens, quotes (smart and straight)
                        // Keep only letters, numbers, and spaces
                        if (/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/.test(char)) {
                            // Skip punctuation
                            continue;
                        }

                        // Collapse whitespace
                        if (/\s/.test(char)) {
                            if (normalizedText.length > 0 && normalizedText[normalizedText.length - 1] === ' ') {
                                continue;
                            }
                            map.push(i);
                            normalizedText += ' ';
                            continue;
                        }

                        map.push(i);
                        normalizedText += char.toLowerCase();
                    }
                }

                return { text: normalizedText, map };
            }

            // Helper to strip parenthetical/bracketed glosses from figurative text (e.g. "foo (lit. bar)")
            static cleanFigurativeText(text, language) {
                if (!text) return '';
                if (language === 'hebrew') return text;

                // Remove parenthetical explanations like "(lit. ...)"
                let coreText = text.replace(/\s*\([^)]*\)/g, '');

                // Clean up whitespace
                return coreText.replace(/\s+/g, ' ').trim();
            }

            // Main Entry: Find Ranges
            // Returns [{start, end, type, data}] (indices in original HTML)
            static findRanges(html, annotations, searchTerm, language) {
                const results = [];
                const logs = [];

                // 1. HTML -> Plain
                const plainObj = this.buildMap(html);

                // 2. Plain -> Normalized
                const normObj = this.buildNormalizationMap(plainObj.text, language);

                // 3. Search for Annotations
                annotations.forEach(ann => {
                    const phrase = language === 'hebrew' ? ann.figurative_text_in_hebrew : ann.figurative_text;
                    if (!phrase) return;

                    // Clean the figurative phrase first (remove "lit." etc)
                    const cleanPhrase = this.cleanFigurativeText(phrase, language);

                    // Normalize the target phrase using same logic
                    let normPhrase = '';
                    if (language === 'hebrew') {
                        normPhrase = cleanPhrase.normalize('NFD')
                            .replace(/[\u0591-\u05C7\u05F0-\u05F4]/g, '')
                            .replace(/־/g, ' ');
                    } else {
                        normPhrase = cleanPhrase.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '');
                    }

                    if (!normPhrase) return;

                    // Search Loop
                    let pos = 0;

                    // Logic for English ellipses and brackets handling
                    const hasWildcard = cleanPhrase.match(/…|\.\.\.|\[.*?\]/);
                    if (language !== 'hebrew' && hasWildcard) {
                        logs.push(`Wildcard match detected for: ${cleanPhrase}`);
                        // Split into parts by ellipses OR brackets
                        const parts = cleanPhrase.split(/…|\.\.\.|\[.*?\]/).map(p =>
                            p.toLowerCase().replace(/[.,;:!?()[\]{}<>"'\u2018\u2019\u201C\u201D\-]/g, '').trim()
                        ).filter(p => p.length > 0);

                        logs.push(`Parts: ${JSON.stringify(parts)}`);

                        if (parts.length > 0) {
                            // Find all occurrences of the FIRST part
                            let searchPos = 0;
                            while (true) {
                                const startIdx = normObj.text.indexOf(parts[0], searchPos);
                                if (startIdx === -1) break;

                                // Verify subsequent parts follow in order
                                let currentIdx = startIdx + parts[0].length;
                                let allFound = true;
                                let matchEnd = currentIdx;

                                for (let i = 1; i < parts.length; i++) {
                                    // Search for next part AFTER currentIdx
                                    const nextIdx = normObj.text.indexOf(parts[i], currentIdx);
                                    if (nextIdx === -1) {
                                        allFound = false;
                                        break;
                                    }
                                    matchEnd = nextIdx + parts[i].length;
                                    currentIdx = matchEnd;
                                }

                                if (allFound) {
                                    results.push({
                                        startNorm: startIdx,
                                        endNorm: matchEnd,
                                        type: 'figurative',
                                        priority: 1,
                                        data: ann
                                    });
                                    logs.push(`Found match at normIdx: ${startIdx}-${matchEnd}`);
                                }
                                searchPos = startIdx + 1;
                            }
                            return; // Skip standard matching for this annotation
                        }
                    }

                    // Standard exact match
                    while (true) {
                        const idx = normObj.text.indexOf(normPhrase, pos);
                        if (idx === -1) break;

                        results.push({
                            startNorm: idx,
                            endNorm: idx + normPhrase.length,
                            type: 'figurative',
                            priority: 1,
                            data: ann
                        });

                        pos = idx + 1;
                    }
                });

                return { results, logs, normText: normObj.text };
            }
        }

        // --- TEST CASES ---
        const testCases = [
            {
                name: "Isaiah 40:14 - Bracketed God",
                html: "With whom did He consult, and who taught Him...",
                language: "english",
                annotations: [
                    { figurative_text: "Whom did [God] consult" }
                ],
                searchTerm: null
            },
            {
                name: "Isaiah 40:15 - Drop of a bucket",
                html: "Behold, the nations are as a drop of a bucket, and are counted as the small dust of the balance",
                language: "english",
                annotations: [
                    { figurative_text: "nations are as a drop [of a bucket]" } // Hypothesis 1
                ],
                searchTerm: null
            },
            {
                name: "Isaiah 40:15 - Drop FROM a bucket",
                html: "Behold, the nations are as a drop of a bucket...",
                language: "english",
                annotations: [
                    { figurative_text: "nations are as a drop [from a bucket]" } // Hypothesis 2: minor diff inside bracket
                ],
                searchTerm: null
            },
            {
                name: "Isaiah 40:16 - Lebanon",
                html: "And Lebanon is not sufficient to burn, nor the beasts thereof sufficient for a burnt offering.",
                language: "english",
                annotations: [
                    { figurative_text: "Lebanon is not sufficient" } // Standard case
                ],
                searchTerm: null
            }
        ];

        let output = "";
        testCases.forEach(test => {
            output += `<h3>${test.name}</h3>`;
            output += `<p>Verse: "${test.html}"</p>`;
            output += `<p>Annotation: "${test.annotations[0].figurative_text}"</p>`;

            try {
                const res = TextHighlighter.findRanges(test.html, test.annotations, test.searchTerm, test.language);
                output += `<p>Normalized Text: "${res.normText}"</p>`;
                if (res.logs && res.logs.length) {
                    output += `<ul><li>${res.logs.join('</li><li>')}</li></ul>`;
                }

                if (res.results.length > 0) {
                    output += `<p style='color:green'>MATCH FOUND: ${JSON.stringify(res.results)}</p>`;
                } else {
                    output += `<p style='color:red'>NO MATCH</p>`;
                }
            } catch (e) {
                output += `<p style='color:red'>ERROR: ${e.message}</p>`;
            }
            output += "<hr>";
        });

        document.getElementById('results').innerHTML = output;

    </script>
</body>

</html>